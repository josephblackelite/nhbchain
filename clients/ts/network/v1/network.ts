// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               unknown
// source: network/v1/network.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientDuplexStream,
  type ClientOptions,
  type ClientUnaryCall,
  type handleBidiStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "network.v1";

export interface GossipMessage {
  type: number;
  payload: Buffer;
}

export interface Heartbeat {
  unixMillis: number;
}

export interface NetworkEnvelope {
  gossip?: GossipMessage | undefined;
  heartbeat?: Heartbeat | undefined;
}

export interface GossipRequest {
  envelope: NetworkEnvelope | undefined;
}

export interface GossipResponse {
  envelope: NetworkEnvelope | undefined;
}

export interface GetViewRequest {
}

export interface NetworkCounts {
  total: number;
  inbound: number;
  outbound: number;
}

export interface NetworkLimits {
  maxPeers: number;
  maxInbound: number;
  maxOutbound: number;
  rateMsgsPerSec: number;
  burst: number;
  banScore: number;
  greyScore: number;
}

export interface NetworkSelf {
  nodeId: string;
  protocolVersion: number;
  clientVersion: string;
}

export interface SeedInfo {
  nodeId: string;
  address: string;
  source: string;
  notBefore: number;
  notAfter: number;
}

export interface NetworkView {
  networkId: number;
  genesisHash: Buffer;
  counts: NetworkCounts | undefined;
  limits: NetworkLimits | undefined;
  self: NetworkSelf | undefined;
  bootnodes: string[];
  persistentPeers: string[];
  seeds: SeedInfo[];
  listenAddrs: string[];
}

export interface GetViewResponse {
  view: NetworkView | undefined;
}

export interface ListPeersRequest {
}

export interface PeerNetInfo {
  nodeId: string;
  address: string;
  direction: string;
  state: string;
  score: number;
  lastSeenUnix: number;
  fails: number;
  bannedUntilUnix: number;
}

export interface ListPeersResponse {
  peers: PeerNetInfo[];
}

export interface DialPeerRequest {
  target: string;
}

export interface DialPeerResponse {
}

export interface BanPeerRequest {
  nodeId: string;
  seconds: number;
}

export interface BanPeerResponse {
}

function createBaseGossipMessage(): GossipMessage {
  return { type: 0, payload: Buffer.alloc(0) };
}

export const GossipMessage: MessageFns<GossipMessage> = {
  encode(message: GossipMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).uint32(message.type);
    }
    if (message.payload.length !== 0) {
      writer.uint32(18).bytes(message.payload);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GossipMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGossipMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payload = Buffer.from(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GossipMessage {
    return {
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      payload: isSet(object.payload) ? Buffer.from(bytesFromBase64(object.payload)) : Buffer.alloc(0),
    };
  },

  toJSON(message: GossipMessage): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    return obj;
  },

  create(base?: DeepPartial<GossipMessage>): GossipMessage {
    return GossipMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GossipMessage>): GossipMessage {
    const message = createBaseGossipMessage();
    message.type = object.type ?? 0;
    message.payload = object.payload ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseHeartbeat(): Heartbeat {
  return { unixMillis: 0 };
}

export const Heartbeat: MessageFns<Heartbeat> = {
  encode(message: Heartbeat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unixMillis !== 0) {
      writer.uint32(8).int64(message.unixMillis);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Heartbeat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.unixMillis = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Heartbeat {
    return { unixMillis: isSet(object.unixMillis) ? globalThis.Number(object.unixMillis) : 0 };
  },

  toJSON(message: Heartbeat): unknown {
    const obj: any = {};
    if (message.unixMillis !== 0) {
      obj.unixMillis = Math.round(message.unixMillis);
    }
    return obj;
  },

  create(base?: DeepPartial<Heartbeat>): Heartbeat {
    return Heartbeat.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Heartbeat>): Heartbeat {
    const message = createBaseHeartbeat();
    message.unixMillis = object.unixMillis ?? 0;
    return message;
  },
};

function createBaseNetworkEnvelope(): NetworkEnvelope {
  return { gossip: undefined, heartbeat: undefined };
}

export const NetworkEnvelope: MessageFns<NetworkEnvelope> = {
  encode(message: NetworkEnvelope, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gossip !== undefined) {
      GossipMessage.encode(message.gossip, writer.uint32(10).fork()).join();
    }
    if (message.heartbeat !== undefined) {
      Heartbeat.encode(message.heartbeat, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkEnvelope {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkEnvelope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gossip = GossipMessage.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.heartbeat = Heartbeat.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkEnvelope {
    return {
      gossip: isSet(object.gossip) ? GossipMessage.fromJSON(object.gossip) : undefined,
      heartbeat: isSet(object.heartbeat) ? Heartbeat.fromJSON(object.heartbeat) : undefined,
    };
  },

  toJSON(message: NetworkEnvelope): unknown {
    const obj: any = {};
    if (message.gossip !== undefined) {
      obj.gossip = GossipMessage.toJSON(message.gossip);
    }
    if (message.heartbeat !== undefined) {
      obj.heartbeat = Heartbeat.toJSON(message.heartbeat);
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkEnvelope>): NetworkEnvelope {
    return NetworkEnvelope.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkEnvelope>): NetworkEnvelope {
    const message = createBaseNetworkEnvelope();
    message.gossip = (object.gossip !== undefined && object.gossip !== null)
      ? GossipMessage.fromPartial(object.gossip)
      : undefined;
    message.heartbeat = (object.heartbeat !== undefined && object.heartbeat !== null)
      ? Heartbeat.fromPartial(object.heartbeat)
      : undefined;
    return message;
  },
};

function createBaseGossipRequest(): GossipRequest {
  return { envelope: undefined };
}

export const GossipRequest: MessageFns<GossipRequest> = {
  encode(message: GossipRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.envelope !== undefined) {
      NetworkEnvelope.encode(message.envelope, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GossipRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGossipRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.envelope = NetworkEnvelope.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GossipRequest {
    return { envelope: isSet(object.envelope) ? NetworkEnvelope.fromJSON(object.envelope) : undefined };
  },

  toJSON(message: GossipRequest): unknown {
    const obj: any = {};
    if (message.envelope !== undefined) {
      obj.envelope = NetworkEnvelope.toJSON(message.envelope);
    }
    return obj;
  },

  create(base?: DeepPartial<GossipRequest>): GossipRequest {
    return GossipRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GossipRequest>): GossipRequest {
    const message = createBaseGossipRequest();
    message.envelope = (object.envelope !== undefined && object.envelope !== null)
      ? NetworkEnvelope.fromPartial(object.envelope)
      : undefined;
    return message;
  },
};

function createBaseGossipResponse(): GossipResponse {
  return { envelope: undefined };
}

export const GossipResponse: MessageFns<GossipResponse> = {
  encode(message: GossipResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.envelope !== undefined) {
      NetworkEnvelope.encode(message.envelope, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GossipResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGossipResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.envelope = NetworkEnvelope.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GossipResponse {
    return { envelope: isSet(object.envelope) ? NetworkEnvelope.fromJSON(object.envelope) : undefined };
  },

  toJSON(message: GossipResponse): unknown {
    const obj: any = {};
    if (message.envelope !== undefined) {
      obj.envelope = NetworkEnvelope.toJSON(message.envelope);
    }
    return obj;
  },

  create(base?: DeepPartial<GossipResponse>): GossipResponse {
    return GossipResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GossipResponse>): GossipResponse {
    const message = createBaseGossipResponse();
    message.envelope = (object.envelope !== undefined && object.envelope !== null)
      ? NetworkEnvelope.fromPartial(object.envelope)
      : undefined;
    return message;
  },
};

function createBaseGetViewRequest(): GetViewRequest {
  return {};
}

export const GetViewRequest: MessageFns<GetViewRequest> = {
  encode(_: GetViewRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetViewRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetViewRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetViewRequest {
    return {};
  },

  toJSON(_: GetViewRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<GetViewRequest>): GetViewRequest {
    return GetViewRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetViewRequest>): GetViewRequest {
    const message = createBaseGetViewRequest();
    return message;
  },
};

function createBaseNetworkCounts(): NetworkCounts {
  return { total: 0, inbound: 0, outbound: 0 };
}

export const NetworkCounts: MessageFns<NetworkCounts> = {
  encode(message: NetworkCounts, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.total !== 0) {
      writer.uint32(8).int32(message.total);
    }
    if (message.inbound !== 0) {
      writer.uint32(16).int32(message.inbound);
    }
    if (message.outbound !== 0) {
      writer.uint32(24).int32(message.outbound);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkCounts {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkCounts();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.inbound = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.outbound = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkCounts {
    return {
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      inbound: isSet(object.inbound) ? globalThis.Number(object.inbound) : 0,
      outbound: isSet(object.outbound) ? globalThis.Number(object.outbound) : 0,
    };
  },

  toJSON(message: NetworkCounts): unknown {
    const obj: any = {};
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.inbound !== 0) {
      obj.inbound = Math.round(message.inbound);
    }
    if (message.outbound !== 0) {
      obj.outbound = Math.round(message.outbound);
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkCounts>): NetworkCounts {
    return NetworkCounts.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkCounts>): NetworkCounts {
    const message = createBaseNetworkCounts();
    message.total = object.total ?? 0;
    message.inbound = object.inbound ?? 0;
    message.outbound = object.outbound ?? 0;
    return message;
  },
};

function createBaseNetworkLimits(): NetworkLimits {
  return { maxPeers: 0, maxInbound: 0, maxOutbound: 0, rateMsgsPerSec: 0, burst: 0, banScore: 0, greyScore: 0 };
}

export const NetworkLimits: MessageFns<NetworkLimits> = {
  encode(message: NetworkLimits, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.maxPeers !== 0) {
      writer.uint32(8).int32(message.maxPeers);
    }
    if (message.maxInbound !== 0) {
      writer.uint32(16).int32(message.maxInbound);
    }
    if (message.maxOutbound !== 0) {
      writer.uint32(24).int32(message.maxOutbound);
    }
    if (message.rateMsgsPerSec !== 0) {
      writer.uint32(33).double(message.rateMsgsPerSec);
    }
    if (message.burst !== 0) {
      writer.uint32(41).double(message.burst);
    }
    if (message.banScore !== 0) {
      writer.uint32(48).int32(message.banScore);
    }
    if (message.greyScore !== 0) {
      writer.uint32(56).int32(message.greyScore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkLimits {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkLimits();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.maxPeers = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxInbound = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxOutbound = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.rateMsgsPerSec = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.burst = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.banScore = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.greyScore = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkLimits {
    return {
      maxPeers: isSet(object.maxPeers) ? globalThis.Number(object.maxPeers) : 0,
      maxInbound: isSet(object.maxInbound) ? globalThis.Number(object.maxInbound) : 0,
      maxOutbound: isSet(object.maxOutbound) ? globalThis.Number(object.maxOutbound) : 0,
      rateMsgsPerSec: isSet(object.rateMsgsPerSec) ? globalThis.Number(object.rateMsgsPerSec) : 0,
      burst: isSet(object.burst) ? globalThis.Number(object.burst) : 0,
      banScore: isSet(object.banScore) ? globalThis.Number(object.banScore) : 0,
      greyScore: isSet(object.greyScore) ? globalThis.Number(object.greyScore) : 0,
    };
  },

  toJSON(message: NetworkLimits): unknown {
    const obj: any = {};
    if (message.maxPeers !== 0) {
      obj.maxPeers = Math.round(message.maxPeers);
    }
    if (message.maxInbound !== 0) {
      obj.maxInbound = Math.round(message.maxInbound);
    }
    if (message.maxOutbound !== 0) {
      obj.maxOutbound = Math.round(message.maxOutbound);
    }
    if (message.rateMsgsPerSec !== 0) {
      obj.rateMsgsPerSec = message.rateMsgsPerSec;
    }
    if (message.burst !== 0) {
      obj.burst = message.burst;
    }
    if (message.banScore !== 0) {
      obj.banScore = Math.round(message.banScore);
    }
    if (message.greyScore !== 0) {
      obj.greyScore = Math.round(message.greyScore);
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkLimits>): NetworkLimits {
    return NetworkLimits.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkLimits>): NetworkLimits {
    const message = createBaseNetworkLimits();
    message.maxPeers = object.maxPeers ?? 0;
    message.maxInbound = object.maxInbound ?? 0;
    message.maxOutbound = object.maxOutbound ?? 0;
    message.rateMsgsPerSec = object.rateMsgsPerSec ?? 0;
    message.burst = object.burst ?? 0;
    message.banScore = object.banScore ?? 0;
    message.greyScore = object.greyScore ?? 0;
    return message;
  },
};

function createBaseNetworkSelf(): NetworkSelf {
  return { nodeId: "", protocolVersion: 0, clientVersion: "" };
}

export const NetworkSelf: MessageFns<NetworkSelf> = {
  encode(message: NetworkSelf, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.protocolVersion !== 0) {
      writer.uint32(16).uint32(message.protocolVersion);
    }
    if (message.clientVersion !== "") {
      writer.uint32(26).string(message.clientVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkSelf {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkSelf();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.protocolVersion = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientVersion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkSelf {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      protocolVersion: isSet(object.protocolVersion) ? globalThis.Number(object.protocolVersion) : 0,
      clientVersion: isSet(object.clientVersion) ? globalThis.String(object.clientVersion) : "",
    };
  },

  toJSON(message: NetworkSelf): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.protocolVersion !== 0) {
      obj.protocolVersion = Math.round(message.protocolVersion);
    }
    if (message.clientVersion !== "") {
      obj.clientVersion = message.clientVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkSelf>): NetworkSelf {
    return NetworkSelf.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkSelf>): NetworkSelf {
    const message = createBaseNetworkSelf();
    message.nodeId = object.nodeId ?? "";
    message.protocolVersion = object.protocolVersion ?? 0;
    message.clientVersion = object.clientVersion ?? "";
    return message;
  },
};

function createBaseSeedInfo(): SeedInfo {
  return { nodeId: "", address: "", source: "", notBefore: 0, notAfter: 0 };
}

export const SeedInfo: MessageFns<SeedInfo> = {
  encode(message: SeedInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.source !== "") {
      writer.uint32(26).string(message.source);
    }
    if (message.notBefore !== 0) {
      writer.uint32(32).int64(message.notBefore);
    }
    if (message.notAfter !== 0) {
      writer.uint32(40).int64(message.notAfter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SeedInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSeedInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.notBefore = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.notAfter = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SeedInfo {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      notBefore: isSet(object.notBefore) ? globalThis.Number(object.notBefore) : 0,
      notAfter: isSet(object.notAfter) ? globalThis.Number(object.notAfter) : 0,
    };
  },

  toJSON(message: SeedInfo): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.notBefore !== 0) {
      obj.notBefore = Math.round(message.notBefore);
    }
    if (message.notAfter !== 0) {
      obj.notAfter = Math.round(message.notAfter);
    }
    return obj;
  },

  create(base?: DeepPartial<SeedInfo>): SeedInfo {
    return SeedInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SeedInfo>): SeedInfo {
    const message = createBaseSeedInfo();
    message.nodeId = object.nodeId ?? "";
    message.address = object.address ?? "";
    message.source = object.source ?? "";
    message.notBefore = object.notBefore ?? 0;
    message.notAfter = object.notAfter ?? 0;
    return message;
  },
};

function createBaseNetworkView(): NetworkView {
  return {
    networkId: 0,
    genesisHash: Buffer.alloc(0),
    counts: undefined,
    limits: undefined,
    self: undefined,
    bootnodes: [],
    persistentPeers: [],
    seeds: [],
    listenAddrs: [],
  };
}

export const NetworkView: MessageFns<NetworkView> = {
  encode(message: NetworkView, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.networkId !== 0) {
      writer.uint32(8).uint64(message.networkId);
    }
    if (message.genesisHash.length !== 0) {
      writer.uint32(18).bytes(message.genesisHash);
    }
    if (message.counts !== undefined) {
      NetworkCounts.encode(message.counts, writer.uint32(26).fork()).join();
    }
    if (message.limits !== undefined) {
      NetworkLimits.encode(message.limits, writer.uint32(34).fork()).join();
    }
    if (message.self !== undefined) {
      NetworkSelf.encode(message.self, writer.uint32(42).fork()).join();
    }
    for (const v of message.bootnodes) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.persistentPeers) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.seeds) {
      SeedInfo.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.listenAddrs) {
      writer.uint32(74).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkView {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkView();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.networkId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.genesisHash = Buffer.from(reader.bytes());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.counts = NetworkCounts.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.limits = NetworkLimits.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.self = NetworkSelf.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.bootnodes.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.persistentPeers.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.seeds.push(SeedInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.listenAddrs.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkView {
    return {
      networkId: isSet(object.networkId) ? globalThis.Number(object.networkId) : 0,
      genesisHash: isSet(object.genesisHash) ? Buffer.from(bytesFromBase64(object.genesisHash)) : Buffer.alloc(0),
      counts: isSet(object.counts) ? NetworkCounts.fromJSON(object.counts) : undefined,
      limits: isSet(object.limits) ? NetworkLimits.fromJSON(object.limits) : undefined,
      self: isSet(object.self) ? NetworkSelf.fromJSON(object.self) : undefined,
      bootnodes: globalThis.Array.isArray(object?.bootnodes)
        ? object.bootnodes.map((e: any) => globalThis.String(e))
        : [],
      persistentPeers: globalThis.Array.isArray(object?.persistentPeers)
        ? object.persistentPeers.map((e: any) => globalThis.String(e))
        : [],
      seeds: globalThis.Array.isArray(object?.seeds) ? object.seeds.map((e: any) => SeedInfo.fromJSON(e)) : [],
      listenAddrs: globalThis.Array.isArray(object?.listenAddrs)
        ? object.listenAddrs.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: NetworkView): unknown {
    const obj: any = {};
    if (message.networkId !== 0) {
      obj.networkId = Math.round(message.networkId);
    }
    if (message.genesisHash.length !== 0) {
      obj.genesisHash = base64FromBytes(message.genesisHash);
    }
    if (message.counts !== undefined) {
      obj.counts = NetworkCounts.toJSON(message.counts);
    }
    if (message.limits !== undefined) {
      obj.limits = NetworkLimits.toJSON(message.limits);
    }
    if (message.self !== undefined) {
      obj.self = NetworkSelf.toJSON(message.self);
    }
    if (message.bootnodes?.length) {
      obj.bootnodes = message.bootnodes;
    }
    if (message.persistentPeers?.length) {
      obj.persistentPeers = message.persistentPeers;
    }
    if (message.seeds?.length) {
      obj.seeds = message.seeds.map((e) => SeedInfo.toJSON(e));
    }
    if (message.listenAddrs?.length) {
      obj.listenAddrs = message.listenAddrs;
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkView>): NetworkView {
    return NetworkView.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkView>): NetworkView {
    const message = createBaseNetworkView();
    message.networkId = object.networkId ?? 0;
    message.genesisHash = object.genesisHash ?? Buffer.alloc(0);
    message.counts = (object.counts !== undefined && object.counts !== null)
      ? NetworkCounts.fromPartial(object.counts)
      : undefined;
    message.limits = (object.limits !== undefined && object.limits !== null)
      ? NetworkLimits.fromPartial(object.limits)
      : undefined;
    message.self = (object.self !== undefined && object.self !== null)
      ? NetworkSelf.fromPartial(object.self)
      : undefined;
    message.bootnodes = object.bootnodes?.map((e) => e) || [];
    message.persistentPeers = object.persistentPeers?.map((e) => e) || [];
    message.seeds = object.seeds?.map((e) => SeedInfo.fromPartial(e)) || [];
    message.listenAddrs = object.listenAddrs?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetViewResponse(): GetViewResponse {
  return { view: undefined };
}

export const GetViewResponse: MessageFns<GetViewResponse> = {
  encode(message: GetViewResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.view !== undefined) {
      NetworkView.encode(message.view, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetViewResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetViewResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.view = NetworkView.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetViewResponse {
    return { view: isSet(object.view) ? NetworkView.fromJSON(object.view) : undefined };
  },

  toJSON(message: GetViewResponse): unknown {
    const obj: any = {};
    if (message.view !== undefined) {
      obj.view = NetworkView.toJSON(message.view);
    }
    return obj;
  },

  create(base?: DeepPartial<GetViewResponse>): GetViewResponse {
    return GetViewResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetViewResponse>): GetViewResponse {
    const message = createBaseGetViewResponse();
    message.view = (object.view !== undefined && object.view !== null)
      ? NetworkView.fromPartial(object.view)
      : undefined;
    return message;
  },
};

function createBaseListPeersRequest(): ListPeersRequest {
  return {};
}

export const ListPeersRequest: MessageFns<ListPeersRequest> = {
  encode(_: ListPeersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPeersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPeersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListPeersRequest {
    return {};
  },

  toJSON(_: ListPeersRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ListPeersRequest>): ListPeersRequest {
    return ListPeersRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ListPeersRequest>): ListPeersRequest {
    const message = createBaseListPeersRequest();
    return message;
  },
};

function createBasePeerNetInfo(): PeerNetInfo {
  return { nodeId: "", address: "", direction: "", state: "", score: 0, lastSeenUnix: 0, fails: 0, bannedUntilUnix: 0 };
}

export const PeerNetInfo: MessageFns<PeerNetInfo> = {
  encode(message: PeerNetInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.direction !== "") {
      writer.uint32(26).string(message.direction);
    }
    if (message.state !== "") {
      writer.uint32(34).string(message.state);
    }
    if (message.score !== 0) {
      writer.uint32(40).int32(message.score);
    }
    if (message.lastSeenUnix !== 0) {
      writer.uint32(48).int64(message.lastSeenUnix);
    }
    if (message.fails !== 0) {
      writer.uint32(56).int32(message.fails);
    }
    if (message.bannedUntilUnix !== 0) {
      writer.uint32(64).int64(message.bannedUntilUnix);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PeerNetInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePeerNetInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.direction = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.state = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.score = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.lastSeenUnix = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.fails = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.bannedUntilUnix = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PeerNetInfo {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      direction: isSet(object.direction) ? globalThis.String(object.direction) : "",
      state: isSet(object.state) ? globalThis.String(object.state) : "",
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      lastSeenUnix: isSet(object.lastSeenUnix) ? globalThis.Number(object.lastSeenUnix) : 0,
      fails: isSet(object.fails) ? globalThis.Number(object.fails) : 0,
      bannedUntilUnix: isSet(object.bannedUntilUnix) ? globalThis.Number(object.bannedUntilUnix) : 0,
    };
  },

  toJSON(message: PeerNetInfo): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.direction !== "") {
      obj.direction = message.direction;
    }
    if (message.state !== "") {
      obj.state = message.state;
    }
    if (message.score !== 0) {
      obj.score = Math.round(message.score);
    }
    if (message.lastSeenUnix !== 0) {
      obj.lastSeenUnix = Math.round(message.lastSeenUnix);
    }
    if (message.fails !== 0) {
      obj.fails = Math.round(message.fails);
    }
    if (message.bannedUntilUnix !== 0) {
      obj.bannedUntilUnix = Math.round(message.bannedUntilUnix);
    }
    return obj;
  },

  create(base?: DeepPartial<PeerNetInfo>): PeerNetInfo {
    return PeerNetInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PeerNetInfo>): PeerNetInfo {
    const message = createBasePeerNetInfo();
    message.nodeId = object.nodeId ?? "";
    message.address = object.address ?? "";
    message.direction = object.direction ?? "";
    message.state = object.state ?? "";
    message.score = object.score ?? 0;
    message.lastSeenUnix = object.lastSeenUnix ?? 0;
    message.fails = object.fails ?? 0;
    message.bannedUntilUnix = object.bannedUntilUnix ?? 0;
    return message;
  },
};

function createBaseListPeersResponse(): ListPeersResponse {
  return { peers: [] };
}

export const ListPeersResponse: MessageFns<ListPeersResponse> = {
  encode(message: ListPeersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.peers) {
      PeerNetInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPeersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPeersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.peers.push(PeerNetInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPeersResponse {
    return {
      peers: globalThis.Array.isArray(object?.peers) ? object.peers.map((e: any) => PeerNetInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListPeersResponse): unknown {
    const obj: any = {};
    if (message.peers?.length) {
      obj.peers = message.peers.map((e) => PeerNetInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListPeersResponse>): ListPeersResponse {
    return ListPeersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPeersResponse>): ListPeersResponse {
    const message = createBaseListPeersResponse();
    message.peers = object.peers?.map((e) => PeerNetInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDialPeerRequest(): DialPeerRequest {
  return { target: "" };
}

export const DialPeerRequest: MessageFns<DialPeerRequest> = {
  encode(message: DialPeerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.target !== "") {
      writer.uint32(10).string(message.target);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DialPeerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDialPeerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.target = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DialPeerRequest {
    return { target: isSet(object.target) ? globalThis.String(object.target) : "" };
  },

  toJSON(message: DialPeerRequest): unknown {
    const obj: any = {};
    if (message.target !== "") {
      obj.target = message.target;
    }
    return obj;
  },

  create(base?: DeepPartial<DialPeerRequest>): DialPeerRequest {
    return DialPeerRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DialPeerRequest>): DialPeerRequest {
    const message = createBaseDialPeerRequest();
    message.target = object.target ?? "";
    return message;
  },
};

function createBaseDialPeerResponse(): DialPeerResponse {
  return {};
}

export const DialPeerResponse: MessageFns<DialPeerResponse> = {
  encode(_: DialPeerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DialPeerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDialPeerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DialPeerResponse {
    return {};
  },

  toJSON(_: DialPeerResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<DialPeerResponse>): DialPeerResponse {
    return DialPeerResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<DialPeerResponse>): DialPeerResponse {
    const message = createBaseDialPeerResponse();
    return message;
  },
};

function createBaseBanPeerRequest(): BanPeerRequest {
  return { nodeId: "", seconds: 0 };
}

export const BanPeerRequest: MessageFns<BanPeerRequest> = {
  encode(message: BanPeerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.seconds !== 0) {
      writer.uint32(16).int64(message.seconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BanPeerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBanPeerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.seconds = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BanPeerRequest {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      seconds: isSet(object.seconds) ? globalThis.Number(object.seconds) : 0,
    };
  },

  toJSON(message: BanPeerRequest): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.seconds !== 0) {
      obj.seconds = Math.round(message.seconds);
    }
    return obj;
  },

  create(base?: DeepPartial<BanPeerRequest>): BanPeerRequest {
    return BanPeerRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BanPeerRequest>): BanPeerRequest {
    const message = createBaseBanPeerRequest();
    message.nodeId = object.nodeId ?? "";
    message.seconds = object.seconds ?? 0;
    return message;
  },
};

function createBaseBanPeerResponse(): BanPeerResponse {
  return {};
}

export const BanPeerResponse: MessageFns<BanPeerResponse> = {
  encode(_: BanPeerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BanPeerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBanPeerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): BanPeerResponse {
    return {};
  },

  toJSON(_: BanPeerResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<BanPeerResponse>): BanPeerResponse {
    return BanPeerResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<BanPeerResponse>): BanPeerResponse {
    const message = createBaseBanPeerResponse();
    return message;
  },
};

export type NetworkServiceService = typeof NetworkServiceService;
export const NetworkServiceService = {
  gossip: {
    path: "/network.v1.NetworkService/Gossip",
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: GossipRequest): Buffer => Buffer.from(GossipRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GossipRequest => GossipRequest.decode(value),
    responseSerialize: (value: GossipResponse): Buffer => Buffer.from(GossipResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GossipResponse => GossipResponse.decode(value),
  },
  getView: {
    path: "/network.v1.NetworkService/GetView",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetViewRequest): Buffer => Buffer.from(GetViewRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetViewRequest => GetViewRequest.decode(value),
    responseSerialize: (value: GetViewResponse): Buffer => Buffer.from(GetViewResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetViewResponse => GetViewResponse.decode(value),
  },
  listPeers: {
    path: "/network.v1.NetworkService/ListPeers",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListPeersRequest): Buffer => Buffer.from(ListPeersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListPeersRequest => ListPeersRequest.decode(value),
    responseSerialize: (value: ListPeersResponse): Buffer => Buffer.from(ListPeersResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListPeersResponse => ListPeersResponse.decode(value),
  },
  dialPeer: {
    path: "/network.v1.NetworkService/DialPeer",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DialPeerRequest): Buffer => Buffer.from(DialPeerRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DialPeerRequest => DialPeerRequest.decode(value),
    responseSerialize: (value: DialPeerResponse): Buffer => Buffer.from(DialPeerResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DialPeerResponse => DialPeerResponse.decode(value),
  },
  banPeer: {
    path: "/network.v1.NetworkService/BanPeer",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BanPeerRequest): Buffer => Buffer.from(BanPeerRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): BanPeerRequest => BanPeerRequest.decode(value),
    responseSerialize: (value: BanPeerResponse): Buffer => Buffer.from(BanPeerResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BanPeerResponse => BanPeerResponse.decode(value),
  },
} as const;

export interface NetworkServiceServer extends UntypedServiceImplementation {
  gossip: handleBidiStreamingCall<GossipRequest, GossipResponse>;
  getView: handleUnaryCall<GetViewRequest, GetViewResponse>;
  listPeers: handleUnaryCall<ListPeersRequest, ListPeersResponse>;
  dialPeer: handleUnaryCall<DialPeerRequest, DialPeerResponse>;
  banPeer: handleUnaryCall<BanPeerRequest, BanPeerResponse>;
}

export interface NetworkServiceClient extends Client {
  gossip(): ClientDuplexStream<GossipRequest, GossipResponse>;
  gossip(options: Partial<CallOptions>): ClientDuplexStream<GossipRequest, GossipResponse>;
  gossip(metadata: Metadata, options?: Partial<CallOptions>): ClientDuplexStream<GossipRequest, GossipResponse>;
  getView(
    request: GetViewRequest,
    callback: (error: ServiceError | null, response: GetViewResponse) => void,
  ): ClientUnaryCall;
  getView(
    request: GetViewRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetViewResponse) => void,
  ): ClientUnaryCall;
  getView(
    request: GetViewRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetViewResponse) => void,
  ): ClientUnaryCall;
  listPeers(
    request: ListPeersRequest,
    callback: (error: ServiceError | null, response: ListPeersResponse) => void,
  ): ClientUnaryCall;
  listPeers(
    request: ListPeersRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListPeersResponse) => void,
  ): ClientUnaryCall;
  listPeers(
    request: ListPeersRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListPeersResponse) => void,
  ): ClientUnaryCall;
  dialPeer(
    request: DialPeerRequest,
    callback: (error: ServiceError | null, response: DialPeerResponse) => void,
  ): ClientUnaryCall;
  dialPeer(
    request: DialPeerRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DialPeerResponse) => void,
  ): ClientUnaryCall;
  dialPeer(
    request: DialPeerRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DialPeerResponse) => void,
  ): ClientUnaryCall;
  banPeer(
    request: BanPeerRequest,
    callback: (error: ServiceError | null, response: BanPeerResponse) => void,
  ): ClientUnaryCall;
  banPeer(
    request: BanPeerRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BanPeerResponse) => void,
  ): ClientUnaryCall;
  banPeer(
    request: BanPeerRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BanPeerResponse) => void,
  ): ClientUnaryCall;
}

export const NetworkServiceClient = makeGenericClientConstructor(
  NetworkServiceService,
  "network.v1.NetworkService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): NetworkServiceClient;
  service: typeof NetworkServiceService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}

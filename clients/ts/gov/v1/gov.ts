// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               unknown
// source: gov/v1/gov.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "gov.v1";

export enum ProposalStatus {
  PROPOSAL_STATUS_UNSPECIFIED = 0,
  PROPOSAL_STATUS_VOTING = 1,
  PROPOSAL_STATUS_ACCEPTED = 2,
  PROPOSAL_STATUS_REJECTED = 3,
  PROPOSAL_STATUS_EXECUTED = 4,
  UNRECOGNIZED = -1,
}

export function proposalStatusFromJSON(object: any): ProposalStatus {
  switch (object) {
    case 0:
    case "PROPOSAL_STATUS_UNSPECIFIED":
      return ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED;
    case 1:
    case "PROPOSAL_STATUS_VOTING":
      return ProposalStatus.PROPOSAL_STATUS_VOTING;
    case 2:
    case "PROPOSAL_STATUS_ACCEPTED":
      return ProposalStatus.PROPOSAL_STATUS_ACCEPTED;
    case 3:
    case "PROPOSAL_STATUS_REJECTED":
      return ProposalStatus.PROPOSAL_STATUS_REJECTED;
    case 4:
    case "PROPOSAL_STATUS_EXECUTED":
      return ProposalStatus.PROPOSAL_STATUS_EXECUTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProposalStatus.UNRECOGNIZED;
  }
}

export function proposalStatusToJSON(object: ProposalStatus): string {
  switch (object) {
    case ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED:
      return "PROPOSAL_STATUS_UNSPECIFIED";
    case ProposalStatus.PROPOSAL_STATUS_VOTING:
      return "PROPOSAL_STATUS_VOTING";
    case ProposalStatus.PROPOSAL_STATUS_ACCEPTED:
      return "PROPOSAL_STATUS_ACCEPTED";
    case ProposalStatus.PROPOSAL_STATUS_REJECTED:
      return "PROPOSAL_STATUS_REJECTED";
    case ProposalStatus.PROPOSAL_STATUS_EXECUTED:
      return "PROPOSAL_STATUS_EXECUTED";
    case ProposalStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ProposalId {
  value: number;
}

export interface Proposal {
  id: ProposalId | undefined;
  title: string;
  summary: string;
  proposer: string;
  status: ProposalStatus;
  submitTimeUnix: number;
  votingEndUnix: number;
}

export interface SubmitProposalRequest {
  proposer: string;
  title: string;
  summary: string;
}

export interface SubmitProposalResponse {
  proposal: Proposal | undefined;
}

export interface GetProposalRequest {
  id: ProposalId | undefined;
}

export interface GetProposalResponse {
  proposal: Proposal | undefined;
}

export interface ListProposalsRequest {
  statusFilter: string;
  pageSize: number;
  pageToken: string;
}

export interface ListProposalsResponse {
  proposals: Proposal[];
  nextPageToken: string;
}

export interface Vote {
  voter: string;
  proposalId: ProposalId | undefined;
  option: string;
}

export interface SubmitVoteRequest {
  vote: Vote | undefined;
}

export interface SubmitVoteResponse {
  vote: Vote | undefined;
}

function createBaseProposalId(): ProposalId {
  return { value: 0 };
}

export const ProposalId: MessageFns<ProposalId> = {
  encode(message: ProposalId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(8).uint64(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProposalId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProposalId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProposalId {
    return { value: isSet(object.value) ? globalThis.Number(object.value) : 0 };
  },

  toJSON(message: ProposalId): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<ProposalId>): ProposalId {
    return ProposalId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProposalId>): ProposalId {
    const message = createBaseProposalId();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseProposal(): Proposal {
  return { id: undefined, title: "", summary: "", proposer: "", status: 0, submitTimeUnix: 0, votingEndUnix: 0 };
}

export const Proposal: MessageFns<Proposal> = {
  encode(message: Proposal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      ProposalId.encode(message.id, writer.uint32(10).fork()).join();
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.summary !== "") {
      writer.uint32(26).string(message.summary);
    }
    if (message.proposer !== "") {
      writer.uint32(34).string(message.proposer);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    if (message.submitTimeUnix !== 0) {
      writer.uint32(48).int64(message.submitTimeUnix);
    }
    if (message.votingEndUnix !== 0) {
      writer.uint32(56).int64(message.votingEndUnix);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Proposal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = ProposalId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.summary = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.proposer = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.submitTimeUnix = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.votingEndUnix = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Proposal {
    return {
      id: isSet(object.id) ? ProposalId.fromJSON(object.id) : undefined,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      summary: isSet(object.summary) ? globalThis.String(object.summary) : "",
      proposer: isSet(object.proposer) ? globalThis.String(object.proposer) : "",
      status: isSet(object.status) ? proposalStatusFromJSON(object.status) : 0,
      submitTimeUnix: isSet(object.submitTimeUnix) ? globalThis.Number(object.submitTimeUnix) : 0,
      votingEndUnix: isSet(object.votingEndUnix) ? globalThis.Number(object.votingEndUnix) : 0,
    };
  },

  toJSON(message: Proposal): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = ProposalId.toJSON(message.id);
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.summary !== "") {
      obj.summary = message.summary;
    }
    if (message.proposer !== "") {
      obj.proposer = message.proposer;
    }
    if (message.status !== 0) {
      obj.status = proposalStatusToJSON(message.status);
    }
    if (message.submitTimeUnix !== 0) {
      obj.submitTimeUnix = Math.round(message.submitTimeUnix);
    }
    if (message.votingEndUnix !== 0) {
      obj.votingEndUnix = Math.round(message.votingEndUnix);
    }
    return obj;
  },

  create(base?: DeepPartial<Proposal>): Proposal {
    return Proposal.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Proposal>): Proposal {
    const message = createBaseProposal();
    message.id = (object.id !== undefined && object.id !== null) ? ProposalId.fromPartial(object.id) : undefined;
    message.title = object.title ?? "";
    message.summary = object.summary ?? "";
    message.proposer = object.proposer ?? "";
    message.status = object.status ?? 0;
    message.submitTimeUnix = object.submitTimeUnix ?? 0;
    message.votingEndUnix = object.votingEndUnix ?? 0;
    return message;
  },
};

function createBaseSubmitProposalRequest(): SubmitProposalRequest {
  return { proposer: "", title: "", summary: "" };
}

export const SubmitProposalRequest: MessageFns<SubmitProposalRequest> = {
  encode(message: SubmitProposalRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.proposer !== "") {
      writer.uint32(10).string(message.proposer);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.summary !== "") {
      writer.uint32(26).string(message.summary);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitProposalRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitProposalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.proposer = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.summary = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitProposalRequest {
    return {
      proposer: isSet(object.proposer) ? globalThis.String(object.proposer) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      summary: isSet(object.summary) ? globalThis.String(object.summary) : "",
    };
  },

  toJSON(message: SubmitProposalRequest): unknown {
    const obj: any = {};
    if (message.proposer !== "") {
      obj.proposer = message.proposer;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.summary !== "") {
      obj.summary = message.summary;
    }
    return obj;
  },

  create(base?: DeepPartial<SubmitProposalRequest>): SubmitProposalRequest {
    return SubmitProposalRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubmitProposalRequest>): SubmitProposalRequest {
    const message = createBaseSubmitProposalRequest();
    message.proposer = object.proposer ?? "";
    message.title = object.title ?? "";
    message.summary = object.summary ?? "";
    return message;
  },
};

function createBaseSubmitProposalResponse(): SubmitProposalResponse {
  return { proposal: undefined };
}

export const SubmitProposalResponse: MessageFns<SubmitProposalResponse> = {
  encode(message: SubmitProposalResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.proposal !== undefined) {
      Proposal.encode(message.proposal, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitProposalResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitProposalResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.proposal = Proposal.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitProposalResponse {
    return { proposal: isSet(object.proposal) ? Proposal.fromJSON(object.proposal) : undefined };
  },

  toJSON(message: SubmitProposalResponse): unknown {
    const obj: any = {};
    if (message.proposal !== undefined) {
      obj.proposal = Proposal.toJSON(message.proposal);
    }
    return obj;
  },

  create(base?: DeepPartial<SubmitProposalResponse>): SubmitProposalResponse {
    return SubmitProposalResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubmitProposalResponse>): SubmitProposalResponse {
    const message = createBaseSubmitProposalResponse();
    message.proposal = (object.proposal !== undefined && object.proposal !== null)
      ? Proposal.fromPartial(object.proposal)
      : undefined;
    return message;
  },
};

function createBaseGetProposalRequest(): GetProposalRequest {
  return { id: undefined };
}

export const GetProposalRequest: MessageFns<GetProposalRequest> = {
  encode(message: GetProposalRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      ProposalId.encode(message.id, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProposalRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProposalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = ProposalId.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProposalRequest {
    return { id: isSet(object.id) ? ProposalId.fromJSON(object.id) : undefined };
  },

  toJSON(message: GetProposalRequest): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = ProposalId.toJSON(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<GetProposalRequest>): GetProposalRequest {
    return GetProposalRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetProposalRequest>): GetProposalRequest {
    const message = createBaseGetProposalRequest();
    message.id = (object.id !== undefined && object.id !== null) ? ProposalId.fromPartial(object.id) : undefined;
    return message;
  },
};

function createBaseGetProposalResponse(): GetProposalResponse {
  return { proposal: undefined };
}

export const GetProposalResponse: MessageFns<GetProposalResponse> = {
  encode(message: GetProposalResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.proposal !== undefined) {
      Proposal.encode(message.proposal, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProposalResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProposalResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.proposal = Proposal.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProposalResponse {
    return { proposal: isSet(object.proposal) ? Proposal.fromJSON(object.proposal) : undefined };
  },

  toJSON(message: GetProposalResponse): unknown {
    const obj: any = {};
    if (message.proposal !== undefined) {
      obj.proposal = Proposal.toJSON(message.proposal);
    }
    return obj;
  },

  create(base?: DeepPartial<GetProposalResponse>): GetProposalResponse {
    return GetProposalResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetProposalResponse>): GetProposalResponse {
    const message = createBaseGetProposalResponse();
    message.proposal = (object.proposal !== undefined && object.proposal !== null)
      ? Proposal.fromPartial(object.proposal)
      : undefined;
    return message;
  },
};

function createBaseListProposalsRequest(): ListProposalsRequest {
  return { statusFilter: "", pageSize: 0, pageToken: "" };
}

export const ListProposalsRequest: MessageFns<ListProposalsRequest> = {
  encode(message: ListProposalsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.statusFilter !== "") {
      writer.uint32(10).string(message.statusFilter);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).uint32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProposalsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProposalsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.statusFilter = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProposalsRequest {
    return {
      statusFilter: isSet(object.statusFilter) ? globalThis.String(object.statusFilter) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListProposalsRequest): unknown {
    const obj: any = {};
    if (message.statusFilter !== "") {
      obj.statusFilter = message.statusFilter;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListProposalsRequest>): ListProposalsRequest {
    return ListProposalsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListProposalsRequest>): ListProposalsRequest {
    const message = createBaseListProposalsRequest();
    message.statusFilter = object.statusFilter ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListProposalsResponse(): ListProposalsResponse {
  return { proposals: [], nextPageToken: "" };
}

export const ListProposalsResponse: MessageFns<ListProposalsResponse> = {
  encode(message: ListProposalsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.proposals) {
      Proposal.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProposalsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProposalsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.proposals.push(Proposal.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProposalsResponse {
    return {
      proposals: globalThis.Array.isArray(object?.proposals)
        ? object.proposals.map((e: any) => Proposal.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListProposalsResponse): unknown {
    const obj: any = {};
    if (message.proposals?.length) {
      obj.proposals = message.proposals.map((e) => Proposal.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListProposalsResponse>): ListProposalsResponse {
    return ListProposalsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListProposalsResponse>): ListProposalsResponse {
    const message = createBaseListProposalsResponse();
    message.proposals = object.proposals?.map((e) => Proposal.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseVote(): Vote {
  return { voter: "", proposalId: undefined, option: "" };
}

export const Vote: MessageFns<Vote> = {
  encode(message: Vote, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.voter !== "") {
      writer.uint32(10).string(message.voter);
    }
    if (message.proposalId !== undefined) {
      ProposalId.encode(message.proposalId, writer.uint32(18).fork()).join();
    }
    if (message.option !== "") {
      writer.uint32(26).string(message.option);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Vote {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.voter = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.proposalId = ProposalId.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.option = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Vote {
    return {
      voter: isSet(object.voter) ? globalThis.String(object.voter) : "",
      proposalId: isSet(object.proposalId) ? ProposalId.fromJSON(object.proposalId) : undefined,
      option: isSet(object.option) ? globalThis.String(object.option) : "",
    };
  },

  toJSON(message: Vote): unknown {
    const obj: any = {};
    if (message.voter !== "") {
      obj.voter = message.voter;
    }
    if (message.proposalId !== undefined) {
      obj.proposalId = ProposalId.toJSON(message.proposalId);
    }
    if (message.option !== "") {
      obj.option = message.option;
    }
    return obj;
  },

  create(base?: DeepPartial<Vote>): Vote {
    return Vote.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Vote>): Vote {
    const message = createBaseVote();
    message.voter = object.voter ?? "";
    message.proposalId = (object.proposalId !== undefined && object.proposalId !== null)
      ? ProposalId.fromPartial(object.proposalId)
      : undefined;
    message.option = object.option ?? "";
    return message;
  },
};

function createBaseSubmitVoteRequest(): SubmitVoteRequest {
  return { vote: undefined };
}

export const SubmitVoteRequest: MessageFns<SubmitVoteRequest> = {
  encode(message: SubmitVoteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vote !== undefined) {
      Vote.encode(message.vote, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitVoteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitVoteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.vote = Vote.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitVoteRequest {
    return { vote: isSet(object.vote) ? Vote.fromJSON(object.vote) : undefined };
  },

  toJSON(message: SubmitVoteRequest): unknown {
    const obj: any = {};
    if (message.vote !== undefined) {
      obj.vote = Vote.toJSON(message.vote);
    }
    return obj;
  },

  create(base?: DeepPartial<SubmitVoteRequest>): SubmitVoteRequest {
    return SubmitVoteRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubmitVoteRequest>): SubmitVoteRequest {
    const message = createBaseSubmitVoteRequest();
    message.vote = (object.vote !== undefined && object.vote !== null) ? Vote.fromPartial(object.vote) : undefined;
    return message;
  },
};

function createBaseSubmitVoteResponse(): SubmitVoteResponse {
  return { vote: undefined };
}

export const SubmitVoteResponse: MessageFns<SubmitVoteResponse> = {
  encode(message: SubmitVoteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vote !== undefined) {
      Vote.encode(message.vote, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitVoteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitVoteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.vote = Vote.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitVoteResponse {
    return { vote: isSet(object.vote) ? Vote.fromJSON(object.vote) : undefined };
  },

  toJSON(message: SubmitVoteResponse): unknown {
    const obj: any = {};
    if (message.vote !== undefined) {
      obj.vote = Vote.toJSON(message.vote);
    }
    return obj;
  },

  create(base?: DeepPartial<SubmitVoteResponse>): SubmitVoteResponse {
    return SubmitVoteResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubmitVoteResponse>): SubmitVoteResponse {
    const message = createBaseSubmitVoteResponse();
    message.vote = (object.vote !== undefined && object.vote !== null) ? Vote.fromPartial(object.vote) : undefined;
    return message;
  },
};

export type GovernanceServiceService = typeof GovernanceServiceService;
export const GovernanceServiceService = {
  submitProposal: {
    path: "/gov.v1.GovernanceService/SubmitProposal",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SubmitProposalRequest): Buffer =>
      Buffer.from(SubmitProposalRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SubmitProposalRequest => SubmitProposalRequest.decode(value),
    responseSerialize: (value: SubmitProposalResponse): Buffer =>
      Buffer.from(SubmitProposalResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SubmitProposalResponse => SubmitProposalResponse.decode(value),
  },
  getProposal: {
    path: "/gov.v1.GovernanceService/GetProposal",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetProposalRequest): Buffer => Buffer.from(GetProposalRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetProposalRequest => GetProposalRequest.decode(value),
    responseSerialize: (value: GetProposalResponse): Buffer => Buffer.from(GetProposalResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetProposalResponse => GetProposalResponse.decode(value),
  },
  listProposals: {
    path: "/gov.v1.GovernanceService/ListProposals",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListProposalsRequest): Buffer => Buffer.from(ListProposalsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListProposalsRequest => ListProposalsRequest.decode(value),
    responseSerialize: (value: ListProposalsResponse): Buffer =>
      Buffer.from(ListProposalsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListProposalsResponse => ListProposalsResponse.decode(value),
  },
  submitVote: {
    path: "/gov.v1.GovernanceService/SubmitVote",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SubmitVoteRequest): Buffer => Buffer.from(SubmitVoteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SubmitVoteRequest => SubmitVoteRequest.decode(value),
    responseSerialize: (value: SubmitVoteResponse): Buffer => Buffer.from(SubmitVoteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SubmitVoteResponse => SubmitVoteResponse.decode(value),
  },
} as const;

export interface GovernanceServiceServer extends UntypedServiceImplementation {
  submitProposal: handleUnaryCall<SubmitProposalRequest, SubmitProposalResponse>;
  getProposal: handleUnaryCall<GetProposalRequest, GetProposalResponse>;
  listProposals: handleUnaryCall<ListProposalsRequest, ListProposalsResponse>;
  submitVote: handleUnaryCall<SubmitVoteRequest, SubmitVoteResponse>;
}

export interface GovernanceServiceClient extends Client {
  submitProposal(
    request: SubmitProposalRequest,
    callback: (error: ServiceError | null, response: SubmitProposalResponse) => void,
  ): ClientUnaryCall;
  submitProposal(
    request: SubmitProposalRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SubmitProposalResponse) => void,
  ): ClientUnaryCall;
  submitProposal(
    request: SubmitProposalRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SubmitProposalResponse) => void,
  ): ClientUnaryCall;
  getProposal(
    request: GetProposalRequest,
    callback: (error: ServiceError | null, response: GetProposalResponse) => void,
  ): ClientUnaryCall;
  getProposal(
    request: GetProposalRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetProposalResponse) => void,
  ): ClientUnaryCall;
  getProposal(
    request: GetProposalRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetProposalResponse) => void,
  ): ClientUnaryCall;
  listProposals(
    request: ListProposalsRequest,
    callback: (error: ServiceError | null, response: ListProposalsResponse) => void,
  ): ClientUnaryCall;
  listProposals(
    request: ListProposalsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListProposalsResponse) => void,
  ): ClientUnaryCall;
  listProposals(
    request: ListProposalsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListProposalsResponse) => void,
  ): ClientUnaryCall;
  submitVote(
    request: SubmitVoteRequest,
    callback: (error: ServiceError | null, response: SubmitVoteResponse) => void,
  ): ClientUnaryCall;
  submitVote(
    request: SubmitVoteRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SubmitVoteResponse) => void,
  ): ClientUnaryCall;
  submitVote(
    request: SubmitVoteRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SubmitVoteResponse) => void,
  ): ClientUnaryCall;
}

export const GovernanceServiceClient = makeGenericClientConstructor(
  GovernanceServiceService,
  "gov.v1.GovernanceService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): GovernanceServiceClient;
  service: typeof GovernanceServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}

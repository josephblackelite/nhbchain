// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               unknown
// source: lending/v1/lending.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "lending.v1";

export interface MarketKey {
  symbol: string;
}

export interface Market {
  key: MarketKey | undefined;
  baseAsset: string;
  collateralFactor: string;
  reserveFactor: string;
  liquidityIndex: string;
  borrowIndex: string;
}

export interface AccountPosition {
  account: string;
  supplied: string;
  borrowed: string;
  collateral: string;
  healthFactor: string;
}

export interface GetMarketRequest {
  key: MarketKey | undefined;
}

export interface GetMarketResponse {
  market: Market | undefined;
}

export interface ListMarketsRequest {
}

export interface ListMarketsResponse {
  markets: Market[];
}

export interface GetPositionRequest {
  account: string;
}

export interface GetPositionResponse {
  position: AccountPosition | undefined;
}

export interface SupplyAssetRequest {
  account: string;
  market: MarketKey | undefined;
  amount: string;
}

export interface SupplyAssetResponse {
  position: AccountPosition | undefined;
}

export interface WithdrawAssetRequest {
  account: string;
  market: MarketKey | undefined;
  amount: string;
}

export interface WithdrawAssetResponse {
  position: AccountPosition | undefined;
}

export interface BorrowAssetRequest {
  account: string;
  market: MarketKey | undefined;
  amount: string;
}

export interface BorrowAssetResponse {
  position: AccountPosition | undefined;
}

export interface RepayAssetRequest {
  account: string;
  market: MarketKey | undefined;
  amount: string;
}

export interface RepayAssetResponse {
  position: AccountPosition | undefined;
}

function createBaseMarketKey(): MarketKey {
  return { symbol: "" };
}

export const MarketKey: MessageFns<MarketKey> = {
  encode(message: MarketKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.symbol !== "") {
      writer.uint32(10).string(message.symbol);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MarketKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MarketKey {
    return { symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "" };
  },

  toJSON(message: MarketKey): unknown {
    const obj: any = {};
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    return obj;
  },

  create(base?: DeepPartial<MarketKey>): MarketKey {
    return MarketKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MarketKey>): MarketKey {
    const message = createBaseMarketKey();
    message.symbol = object.symbol ?? "";
    return message;
  },
};

function createBaseMarket(): Market {
  return {
    key: undefined,
    baseAsset: "",
    collateralFactor: "",
    reserveFactor: "",
    liquidityIndex: "",
    borrowIndex: "",
  };
}

export const Market: MessageFns<Market> = {
  encode(message: Market, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      MarketKey.encode(message.key, writer.uint32(10).fork()).join();
    }
    if (message.baseAsset !== "") {
      writer.uint32(18).string(message.baseAsset);
    }
    if (message.collateralFactor !== "") {
      writer.uint32(26).string(message.collateralFactor);
    }
    if (message.reserveFactor !== "") {
      writer.uint32(34).string(message.reserveFactor);
    }
    if (message.liquidityIndex !== "") {
      writer.uint32(42).string(message.liquidityIndex);
    }
    if (message.borrowIndex !== "") {
      writer.uint32(50).string(message.borrowIndex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Market {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = MarketKey.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.baseAsset = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.collateralFactor = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.reserveFactor = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.liquidityIndex = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.borrowIndex = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Market {
    return {
      key: isSet(object.key) ? MarketKey.fromJSON(object.key) : undefined,
      baseAsset: isSet(object.baseAsset) ? globalThis.String(object.baseAsset) : "",
      collateralFactor: isSet(object.collateralFactor) ? globalThis.String(object.collateralFactor) : "",
      reserveFactor: isSet(object.reserveFactor) ? globalThis.String(object.reserveFactor) : "",
      liquidityIndex: isSet(object.liquidityIndex) ? globalThis.String(object.liquidityIndex) : "",
      borrowIndex: isSet(object.borrowIndex) ? globalThis.String(object.borrowIndex) : "",
    };
  },

  toJSON(message: Market): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = MarketKey.toJSON(message.key);
    }
    if (message.baseAsset !== "") {
      obj.baseAsset = message.baseAsset;
    }
    if (message.collateralFactor !== "") {
      obj.collateralFactor = message.collateralFactor;
    }
    if (message.reserveFactor !== "") {
      obj.reserveFactor = message.reserveFactor;
    }
    if (message.liquidityIndex !== "") {
      obj.liquidityIndex = message.liquidityIndex;
    }
    if (message.borrowIndex !== "") {
      obj.borrowIndex = message.borrowIndex;
    }
    return obj;
  },

  create(base?: DeepPartial<Market>): Market {
    return Market.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Market>): Market {
    const message = createBaseMarket();
    message.key = (object.key !== undefined && object.key !== null) ? MarketKey.fromPartial(object.key) : undefined;
    message.baseAsset = object.baseAsset ?? "";
    message.collateralFactor = object.collateralFactor ?? "";
    message.reserveFactor = object.reserveFactor ?? "";
    message.liquidityIndex = object.liquidityIndex ?? "";
    message.borrowIndex = object.borrowIndex ?? "";
    return message;
  },
};

function createBaseAccountPosition(): AccountPosition {
  return { account: "", supplied: "", borrowed: "", collateral: "", healthFactor: "" };
}

export const AccountPosition: MessageFns<AccountPosition> = {
  encode(message: AccountPosition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account !== "") {
      writer.uint32(10).string(message.account);
    }
    if (message.supplied !== "") {
      writer.uint32(18).string(message.supplied);
    }
    if (message.borrowed !== "") {
      writer.uint32(26).string(message.borrowed);
    }
    if (message.collateral !== "") {
      writer.uint32(34).string(message.collateral);
    }
    if (message.healthFactor !== "") {
      writer.uint32(42).string(message.healthFactor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountPosition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountPosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.account = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.supplied = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.borrowed = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.collateral = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.healthFactor = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountPosition {
    return {
      account: isSet(object.account) ? globalThis.String(object.account) : "",
      supplied: isSet(object.supplied) ? globalThis.String(object.supplied) : "",
      borrowed: isSet(object.borrowed) ? globalThis.String(object.borrowed) : "",
      collateral: isSet(object.collateral) ? globalThis.String(object.collateral) : "",
      healthFactor: isSet(object.healthFactor) ? globalThis.String(object.healthFactor) : "",
    };
  },

  toJSON(message: AccountPosition): unknown {
    const obj: any = {};
    if (message.account !== "") {
      obj.account = message.account;
    }
    if (message.supplied !== "") {
      obj.supplied = message.supplied;
    }
    if (message.borrowed !== "") {
      obj.borrowed = message.borrowed;
    }
    if (message.collateral !== "") {
      obj.collateral = message.collateral;
    }
    if (message.healthFactor !== "") {
      obj.healthFactor = message.healthFactor;
    }
    return obj;
  },

  create(base?: DeepPartial<AccountPosition>): AccountPosition {
    return AccountPosition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccountPosition>): AccountPosition {
    const message = createBaseAccountPosition();
    message.account = object.account ?? "";
    message.supplied = object.supplied ?? "";
    message.borrowed = object.borrowed ?? "";
    message.collateral = object.collateral ?? "";
    message.healthFactor = object.healthFactor ?? "";
    return message;
  },
};

function createBaseGetMarketRequest(): GetMarketRequest {
  return { key: undefined };
}

export const GetMarketRequest: MessageFns<GetMarketRequest> = {
  encode(message: GetMarketRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      MarketKey.encode(message.key, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMarketRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMarketRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = MarketKey.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMarketRequest {
    return { key: isSet(object.key) ? MarketKey.fromJSON(object.key) : undefined };
  },

  toJSON(message: GetMarketRequest): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = MarketKey.toJSON(message.key);
    }
    return obj;
  },

  create(base?: DeepPartial<GetMarketRequest>): GetMarketRequest {
    return GetMarketRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetMarketRequest>): GetMarketRequest {
    const message = createBaseGetMarketRequest();
    message.key = (object.key !== undefined && object.key !== null) ? MarketKey.fromPartial(object.key) : undefined;
    return message;
  },
};

function createBaseGetMarketResponse(): GetMarketResponse {
  return { market: undefined };
}

export const GetMarketResponse: MessageFns<GetMarketResponse> = {
  encode(message: GetMarketResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.market !== undefined) {
      Market.encode(message.market, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMarketResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMarketResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.market = Market.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMarketResponse {
    return { market: isSet(object.market) ? Market.fromJSON(object.market) : undefined };
  },

  toJSON(message: GetMarketResponse): unknown {
    const obj: any = {};
    if (message.market !== undefined) {
      obj.market = Market.toJSON(message.market);
    }
    return obj;
  },

  create(base?: DeepPartial<GetMarketResponse>): GetMarketResponse {
    return GetMarketResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetMarketResponse>): GetMarketResponse {
    const message = createBaseGetMarketResponse();
    message.market = (object.market !== undefined && object.market !== null)
      ? Market.fromPartial(object.market)
      : undefined;
    return message;
  },
};

function createBaseListMarketsRequest(): ListMarketsRequest {
  return {};
}

export const ListMarketsRequest: MessageFns<ListMarketsRequest> = {
  encode(_: ListMarketsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListMarketsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListMarketsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListMarketsRequest {
    return {};
  },

  toJSON(_: ListMarketsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ListMarketsRequest>): ListMarketsRequest {
    return ListMarketsRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ListMarketsRequest>): ListMarketsRequest {
    const message = createBaseListMarketsRequest();
    return message;
  },
};

function createBaseListMarketsResponse(): ListMarketsResponse {
  return { markets: [] };
}

export const ListMarketsResponse: MessageFns<ListMarketsResponse> = {
  encode(message: ListMarketsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.markets) {
      Market.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListMarketsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListMarketsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.markets.push(Market.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListMarketsResponse {
    return {
      markets: globalThis.Array.isArray(object?.markets) ? object.markets.map((e: any) => Market.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListMarketsResponse): unknown {
    const obj: any = {};
    if (message.markets?.length) {
      obj.markets = message.markets.map((e) => Market.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListMarketsResponse>): ListMarketsResponse {
    return ListMarketsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListMarketsResponse>): ListMarketsResponse {
    const message = createBaseListMarketsResponse();
    message.markets = object.markets?.map((e) => Market.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetPositionRequest(): GetPositionRequest {
  return { account: "" };
}

export const GetPositionRequest: MessageFns<GetPositionRequest> = {
  encode(message: GetPositionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account !== "") {
      writer.uint32(10).string(message.account);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPositionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPositionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.account = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPositionRequest {
    return { account: isSet(object.account) ? globalThis.String(object.account) : "" };
  },

  toJSON(message: GetPositionRequest): unknown {
    const obj: any = {};
    if (message.account !== "") {
      obj.account = message.account;
    }
    return obj;
  },

  create(base?: DeepPartial<GetPositionRequest>): GetPositionRequest {
    return GetPositionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetPositionRequest>): GetPositionRequest {
    const message = createBaseGetPositionRequest();
    message.account = object.account ?? "";
    return message;
  },
};

function createBaseGetPositionResponse(): GetPositionResponse {
  return { position: undefined };
}

export const GetPositionResponse: MessageFns<GetPositionResponse> = {
  encode(message: GetPositionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.position !== undefined) {
      AccountPosition.encode(message.position, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPositionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPositionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.position = AccountPosition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPositionResponse {
    return { position: isSet(object.position) ? AccountPosition.fromJSON(object.position) : undefined };
  },

  toJSON(message: GetPositionResponse): unknown {
    const obj: any = {};
    if (message.position !== undefined) {
      obj.position = AccountPosition.toJSON(message.position);
    }
    return obj;
  },

  create(base?: DeepPartial<GetPositionResponse>): GetPositionResponse {
    return GetPositionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetPositionResponse>): GetPositionResponse {
    const message = createBaseGetPositionResponse();
    message.position = (object.position !== undefined && object.position !== null)
      ? AccountPosition.fromPartial(object.position)
      : undefined;
    return message;
  },
};

function createBaseSupplyAssetRequest(): SupplyAssetRequest {
  return { account: "", market: undefined, amount: "" };
}

export const SupplyAssetRequest: MessageFns<SupplyAssetRequest> = {
  encode(message: SupplyAssetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account !== "") {
      writer.uint32(10).string(message.account);
    }
    if (message.market !== undefined) {
      MarketKey.encode(message.market, writer.uint32(18).fork()).join();
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SupplyAssetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSupplyAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.account = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.market = MarketKey.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SupplyAssetRequest {
    return {
      account: isSet(object.account) ? globalThis.String(object.account) : "",
      market: isSet(object.market) ? MarketKey.fromJSON(object.market) : undefined,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
    };
  },

  toJSON(message: SupplyAssetRequest): unknown {
    const obj: any = {};
    if (message.account !== "") {
      obj.account = message.account;
    }
    if (message.market !== undefined) {
      obj.market = MarketKey.toJSON(message.market);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create(base?: DeepPartial<SupplyAssetRequest>): SupplyAssetRequest {
    return SupplyAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SupplyAssetRequest>): SupplyAssetRequest {
    const message = createBaseSupplyAssetRequest();
    message.account = object.account ?? "";
    message.market = (object.market !== undefined && object.market !== null)
      ? MarketKey.fromPartial(object.market)
      : undefined;
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseSupplyAssetResponse(): SupplyAssetResponse {
  return { position: undefined };
}

export const SupplyAssetResponse: MessageFns<SupplyAssetResponse> = {
  encode(message: SupplyAssetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.position !== undefined) {
      AccountPosition.encode(message.position, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SupplyAssetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSupplyAssetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.position = AccountPosition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SupplyAssetResponse {
    return { position: isSet(object.position) ? AccountPosition.fromJSON(object.position) : undefined };
  },

  toJSON(message: SupplyAssetResponse): unknown {
    const obj: any = {};
    if (message.position !== undefined) {
      obj.position = AccountPosition.toJSON(message.position);
    }
    return obj;
  },

  create(base?: DeepPartial<SupplyAssetResponse>): SupplyAssetResponse {
    return SupplyAssetResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SupplyAssetResponse>): SupplyAssetResponse {
    const message = createBaseSupplyAssetResponse();
    message.position = (object.position !== undefined && object.position !== null)
      ? AccountPosition.fromPartial(object.position)
      : undefined;
    return message;
  },
};

function createBaseWithdrawAssetRequest(): WithdrawAssetRequest {
  return { account: "", market: undefined, amount: "" };
}

export const WithdrawAssetRequest: MessageFns<WithdrawAssetRequest> = {
  encode(message: WithdrawAssetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account !== "") {
      writer.uint32(10).string(message.account);
    }
    if (message.market !== undefined) {
      MarketKey.encode(message.market, writer.uint32(18).fork()).join();
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WithdrawAssetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWithdrawAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.account = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.market = MarketKey.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WithdrawAssetRequest {
    return {
      account: isSet(object.account) ? globalThis.String(object.account) : "",
      market: isSet(object.market) ? MarketKey.fromJSON(object.market) : undefined,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
    };
  },

  toJSON(message: WithdrawAssetRequest): unknown {
    const obj: any = {};
    if (message.account !== "") {
      obj.account = message.account;
    }
    if (message.market !== undefined) {
      obj.market = MarketKey.toJSON(message.market);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create(base?: DeepPartial<WithdrawAssetRequest>): WithdrawAssetRequest {
    return WithdrawAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WithdrawAssetRequest>): WithdrawAssetRequest {
    const message = createBaseWithdrawAssetRequest();
    message.account = object.account ?? "";
    message.market = (object.market !== undefined && object.market !== null)
      ? MarketKey.fromPartial(object.market)
      : undefined;
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseWithdrawAssetResponse(): WithdrawAssetResponse {
  return { position: undefined };
}

export const WithdrawAssetResponse: MessageFns<WithdrawAssetResponse> = {
  encode(message: WithdrawAssetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.position !== undefined) {
      AccountPosition.encode(message.position, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WithdrawAssetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWithdrawAssetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.position = AccountPosition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WithdrawAssetResponse {
    return { position: isSet(object.position) ? AccountPosition.fromJSON(object.position) : undefined };
  },

  toJSON(message: WithdrawAssetResponse): unknown {
    const obj: any = {};
    if (message.position !== undefined) {
      obj.position = AccountPosition.toJSON(message.position);
    }
    return obj;
  },

  create(base?: DeepPartial<WithdrawAssetResponse>): WithdrawAssetResponse {
    return WithdrawAssetResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WithdrawAssetResponse>): WithdrawAssetResponse {
    const message = createBaseWithdrawAssetResponse();
    message.position = (object.position !== undefined && object.position !== null)
      ? AccountPosition.fromPartial(object.position)
      : undefined;
    return message;
  },
};

function createBaseBorrowAssetRequest(): BorrowAssetRequest {
  return { account: "", market: undefined, amount: "" };
}

export const BorrowAssetRequest: MessageFns<BorrowAssetRequest> = {
  encode(message: BorrowAssetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account !== "") {
      writer.uint32(10).string(message.account);
    }
    if (message.market !== undefined) {
      MarketKey.encode(message.market, writer.uint32(18).fork()).join();
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BorrowAssetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBorrowAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.account = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.market = MarketKey.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BorrowAssetRequest {
    return {
      account: isSet(object.account) ? globalThis.String(object.account) : "",
      market: isSet(object.market) ? MarketKey.fromJSON(object.market) : undefined,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
    };
  },

  toJSON(message: BorrowAssetRequest): unknown {
    const obj: any = {};
    if (message.account !== "") {
      obj.account = message.account;
    }
    if (message.market !== undefined) {
      obj.market = MarketKey.toJSON(message.market);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create(base?: DeepPartial<BorrowAssetRequest>): BorrowAssetRequest {
    return BorrowAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BorrowAssetRequest>): BorrowAssetRequest {
    const message = createBaseBorrowAssetRequest();
    message.account = object.account ?? "";
    message.market = (object.market !== undefined && object.market !== null)
      ? MarketKey.fromPartial(object.market)
      : undefined;
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseBorrowAssetResponse(): BorrowAssetResponse {
  return { position: undefined };
}

export const BorrowAssetResponse: MessageFns<BorrowAssetResponse> = {
  encode(message: BorrowAssetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.position !== undefined) {
      AccountPosition.encode(message.position, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BorrowAssetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBorrowAssetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.position = AccountPosition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BorrowAssetResponse {
    return { position: isSet(object.position) ? AccountPosition.fromJSON(object.position) : undefined };
  },

  toJSON(message: BorrowAssetResponse): unknown {
    const obj: any = {};
    if (message.position !== undefined) {
      obj.position = AccountPosition.toJSON(message.position);
    }
    return obj;
  },

  create(base?: DeepPartial<BorrowAssetResponse>): BorrowAssetResponse {
    return BorrowAssetResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BorrowAssetResponse>): BorrowAssetResponse {
    const message = createBaseBorrowAssetResponse();
    message.position = (object.position !== undefined && object.position !== null)
      ? AccountPosition.fromPartial(object.position)
      : undefined;
    return message;
  },
};

function createBaseRepayAssetRequest(): RepayAssetRequest {
  return { account: "", market: undefined, amount: "" };
}

export const RepayAssetRequest: MessageFns<RepayAssetRequest> = {
  encode(message: RepayAssetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account !== "") {
      writer.uint32(10).string(message.account);
    }
    if (message.market !== undefined) {
      MarketKey.encode(message.market, writer.uint32(18).fork()).join();
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RepayAssetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRepayAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.account = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.market = MarketKey.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RepayAssetRequest {
    return {
      account: isSet(object.account) ? globalThis.String(object.account) : "",
      market: isSet(object.market) ? MarketKey.fromJSON(object.market) : undefined,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
    };
  },

  toJSON(message: RepayAssetRequest): unknown {
    const obj: any = {};
    if (message.account !== "") {
      obj.account = message.account;
    }
    if (message.market !== undefined) {
      obj.market = MarketKey.toJSON(message.market);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create(base?: DeepPartial<RepayAssetRequest>): RepayAssetRequest {
    return RepayAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RepayAssetRequest>): RepayAssetRequest {
    const message = createBaseRepayAssetRequest();
    message.account = object.account ?? "";
    message.market = (object.market !== undefined && object.market !== null)
      ? MarketKey.fromPartial(object.market)
      : undefined;
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseRepayAssetResponse(): RepayAssetResponse {
  return { position: undefined };
}

export const RepayAssetResponse: MessageFns<RepayAssetResponse> = {
  encode(message: RepayAssetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.position !== undefined) {
      AccountPosition.encode(message.position, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RepayAssetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRepayAssetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.position = AccountPosition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RepayAssetResponse {
    return { position: isSet(object.position) ? AccountPosition.fromJSON(object.position) : undefined };
  },

  toJSON(message: RepayAssetResponse): unknown {
    const obj: any = {};
    if (message.position !== undefined) {
      obj.position = AccountPosition.toJSON(message.position);
    }
    return obj;
  },

  create(base?: DeepPartial<RepayAssetResponse>): RepayAssetResponse {
    return RepayAssetResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RepayAssetResponse>): RepayAssetResponse {
    const message = createBaseRepayAssetResponse();
    message.position = (object.position !== undefined && object.position !== null)
      ? AccountPosition.fromPartial(object.position)
      : undefined;
    return message;
  },
};

export type LendingServiceService = typeof LendingServiceService;
export const LendingServiceService = {
  getMarket: {
    path: "/lending.v1.LendingService/GetMarket",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetMarketRequest): Buffer => Buffer.from(GetMarketRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetMarketRequest => GetMarketRequest.decode(value),
    responseSerialize: (value: GetMarketResponse): Buffer => Buffer.from(GetMarketResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetMarketResponse => GetMarketResponse.decode(value),
  },
  listMarkets: {
    path: "/lending.v1.LendingService/ListMarkets",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListMarketsRequest): Buffer => Buffer.from(ListMarketsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListMarketsRequest => ListMarketsRequest.decode(value),
    responseSerialize: (value: ListMarketsResponse): Buffer => Buffer.from(ListMarketsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListMarketsResponse => ListMarketsResponse.decode(value),
  },
  getPosition: {
    path: "/lending.v1.LendingService/GetPosition",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPositionRequest): Buffer => Buffer.from(GetPositionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetPositionRequest => GetPositionRequest.decode(value),
    responseSerialize: (value: GetPositionResponse): Buffer => Buffer.from(GetPositionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetPositionResponse => GetPositionResponse.decode(value),
  },
  supplyAsset: {
    path: "/lending.v1.LendingService/SupplyAsset",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SupplyAssetRequest): Buffer => Buffer.from(SupplyAssetRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SupplyAssetRequest => SupplyAssetRequest.decode(value),
    responseSerialize: (value: SupplyAssetResponse): Buffer => Buffer.from(SupplyAssetResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SupplyAssetResponse => SupplyAssetResponse.decode(value),
  },
  withdrawAsset: {
    path: "/lending.v1.LendingService/WithdrawAsset",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: WithdrawAssetRequest): Buffer => Buffer.from(WithdrawAssetRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): WithdrawAssetRequest => WithdrawAssetRequest.decode(value),
    responseSerialize: (value: WithdrawAssetResponse): Buffer =>
      Buffer.from(WithdrawAssetResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): WithdrawAssetResponse => WithdrawAssetResponse.decode(value),
  },
  borrowAsset: {
    path: "/lending.v1.LendingService/BorrowAsset",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BorrowAssetRequest): Buffer => Buffer.from(BorrowAssetRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): BorrowAssetRequest => BorrowAssetRequest.decode(value),
    responseSerialize: (value: BorrowAssetResponse): Buffer => Buffer.from(BorrowAssetResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BorrowAssetResponse => BorrowAssetResponse.decode(value),
  },
  repayAsset: {
    path: "/lending.v1.LendingService/RepayAsset",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RepayAssetRequest): Buffer => Buffer.from(RepayAssetRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RepayAssetRequest => RepayAssetRequest.decode(value),
    responseSerialize: (value: RepayAssetResponse): Buffer => Buffer.from(RepayAssetResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RepayAssetResponse => RepayAssetResponse.decode(value),
  },
} as const;

export interface LendingServiceServer extends UntypedServiceImplementation {
  getMarket: handleUnaryCall<GetMarketRequest, GetMarketResponse>;
  listMarkets: handleUnaryCall<ListMarketsRequest, ListMarketsResponse>;
  getPosition: handleUnaryCall<GetPositionRequest, GetPositionResponse>;
  supplyAsset: handleUnaryCall<SupplyAssetRequest, SupplyAssetResponse>;
  withdrawAsset: handleUnaryCall<WithdrawAssetRequest, WithdrawAssetResponse>;
  borrowAsset: handleUnaryCall<BorrowAssetRequest, BorrowAssetResponse>;
  repayAsset: handleUnaryCall<RepayAssetRequest, RepayAssetResponse>;
}

export interface LendingServiceClient extends Client {
  getMarket(
    request: GetMarketRequest,
    callback: (error: ServiceError | null, response: GetMarketResponse) => void,
  ): ClientUnaryCall;
  getMarket(
    request: GetMarketRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetMarketResponse) => void,
  ): ClientUnaryCall;
  getMarket(
    request: GetMarketRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetMarketResponse) => void,
  ): ClientUnaryCall;
  listMarkets(
    request: ListMarketsRequest,
    callback: (error: ServiceError | null, response: ListMarketsResponse) => void,
  ): ClientUnaryCall;
  listMarkets(
    request: ListMarketsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListMarketsResponse) => void,
  ): ClientUnaryCall;
  listMarkets(
    request: ListMarketsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListMarketsResponse) => void,
  ): ClientUnaryCall;
  getPosition(
    request: GetPositionRequest,
    callback: (error: ServiceError | null, response: GetPositionResponse) => void,
  ): ClientUnaryCall;
  getPosition(
    request: GetPositionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetPositionResponse) => void,
  ): ClientUnaryCall;
  getPosition(
    request: GetPositionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetPositionResponse) => void,
  ): ClientUnaryCall;
  supplyAsset(
    request: SupplyAssetRequest,
    callback: (error: ServiceError | null, response: SupplyAssetResponse) => void,
  ): ClientUnaryCall;
  supplyAsset(
    request: SupplyAssetRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SupplyAssetResponse) => void,
  ): ClientUnaryCall;
  supplyAsset(
    request: SupplyAssetRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SupplyAssetResponse) => void,
  ): ClientUnaryCall;
  withdrawAsset(
    request: WithdrawAssetRequest,
    callback: (error: ServiceError | null, response: WithdrawAssetResponse) => void,
  ): ClientUnaryCall;
  withdrawAsset(
    request: WithdrawAssetRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: WithdrawAssetResponse) => void,
  ): ClientUnaryCall;
  withdrawAsset(
    request: WithdrawAssetRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: WithdrawAssetResponse) => void,
  ): ClientUnaryCall;
  borrowAsset(
    request: BorrowAssetRequest,
    callback: (error: ServiceError | null, response: BorrowAssetResponse) => void,
  ): ClientUnaryCall;
  borrowAsset(
    request: BorrowAssetRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BorrowAssetResponse) => void,
  ): ClientUnaryCall;
  borrowAsset(
    request: BorrowAssetRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BorrowAssetResponse) => void,
  ): ClientUnaryCall;
  repayAsset(
    request: RepayAssetRequest,
    callback: (error: ServiceError | null, response: RepayAssetResponse) => void,
  ): ClientUnaryCall;
  repayAsset(
    request: RepayAssetRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RepayAssetResponse) => void,
  ): ClientUnaryCall;
  repayAsset(
    request: RepayAssetRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RepayAssetResponse) => void,
  ): ClientUnaryCall;
}

export const LendingServiceClient = makeGenericClientConstructor(
  LendingServiceService,
  "lending.v1.LendingService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): LendingServiceClient;
  service: typeof LendingServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}

// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               unknown
// source: swap/v1/stable.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "swap.v1";

export interface DepositVoucher {
  invoiceId: string;
  provider: string;
  stableAsset: string;
  stableAmount: string;
  nhbAmount: string;
  account: string;
  memo: string;
  createdAt: number;
}

export interface CashOutIntent {
  intentId: string;
  invoiceId: string;
  account: string;
  stableAsset: string;
  stableAmount: string;
  nhbAmount: string;
  status: string;
  createdAt: number;
  settledAt: number;
}

export interface EscrowLock {
  lockId: string;
  intentId: string;
  account: string;
  nhbAmount: string;
  burned: boolean;
  lockedAt: number;
  burnedAt: number;
}

export interface PayoutReceipt {
  receiptId: string;
  intentId: string;
  stableAsset: string;
  stableAmount: string;
  nhbAmount: string;
  txHash: string;
  evidenceUri: string;
  settledAt: number;
}

export interface TreasurySoftInventory {
  stableAsset: string;
  deposits: string;
  payouts: string;
  balance: string;
  updatedAt: number;
}

export interface QueryDepositVoucherRequest {
  invoiceId: string;
}

export interface QueryDepositVoucherResponse {
  voucher: DepositVoucher | undefined;
}

export interface QueryCashOutIntentRequest {
  intentId: string;
}

export interface QueryCashOutIntentResponse {
  intent: CashOutIntent | undefined;
  lock: EscrowLock | undefined;
  receipt: PayoutReceipt | undefined;
}

export interface QuerySoftInventoryRequest {
  stableAsset: string;
}

export interface QuerySoftInventoryResponse {
  inventory: TreasurySoftInventory | undefined;
}

function createBaseDepositVoucher(): DepositVoucher {
  return {
    invoiceId: "",
    provider: "",
    stableAsset: "",
    stableAmount: "",
    nhbAmount: "",
    account: "",
    memo: "",
    createdAt: 0,
  };
}

export const DepositVoucher: MessageFns<DepositVoucher> = {
  encode(message: DepositVoucher, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.invoiceId !== "") {
      writer.uint32(10).string(message.invoiceId);
    }
    if (message.provider !== "") {
      writer.uint32(18).string(message.provider);
    }
    if (message.stableAsset !== "") {
      writer.uint32(26).string(message.stableAsset);
    }
    if (message.stableAmount !== "") {
      writer.uint32(34).string(message.stableAmount);
    }
    if (message.nhbAmount !== "") {
      writer.uint32(42).string(message.nhbAmount);
    }
    if (message.account !== "") {
      writer.uint32(50).string(message.account);
    }
    if (message.memo !== "") {
      writer.uint32(58).string(message.memo);
    }
    if (message.createdAt !== 0) {
      writer.uint32(64).int64(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DepositVoucher {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDepositVoucher();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.invoiceId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.provider = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.stableAsset = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.stableAmount = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nhbAmount = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.account = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.memo = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.createdAt = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DepositVoucher {
    return {
      invoiceId: isSet(object.invoiceId) ? globalThis.String(object.invoiceId) : "",
      provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
      stableAsset: isSet(object.stableAsset) ? globalThis.String(object.stableAsset) : "",
      stableAmount: isSet(object.stableAmount) ? globalThis.String(object.stableAmount) : "",
      nhbAmount: isSet(object.nhbAmount) ? globalThis.String(object.nhbAmount) : "",
      account: isSet(object.account) ? globalThis.String(object.account) : "",
      memo: isSet(object.memo) ? globalThis.String(object.memo) : "",
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
    };
  },

  toJSON(message: DepositVoucher): unknown {
    const obj: any = {};
    if (message.invoiceId !== "") {
      obj.invoiceId = message.invoiceId;
    }
    if (message.provider !== "") {
      obj.provider = message.provider;
    }
    if (message.stableAsset !== "") {
      obj.stableAsset = message.stableAsset;
    }
    if (message.stableAmount !== "") {
      obj.stableAmount = message.stableAmount;
    }
    if (message.nhbAmount !== "") {
      obj.nhbAmount = message.nhbAmount;
    }
    if (message.account !== "") {
      obj.account = message.account;
    }
    if (message.memo !== "") {
      obj.memo = message.memo;
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    return obj;
  },

  create(base?: DeepPartial<DepositVoucher>): DepositVoucher {
    return DepositVoucher.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DepositVoucher>): DepositVoucher {
    const message = createBaseDepositVoucher();
    message.invoiceId = object.invoiceId ?? "";
    message.provider = object.provider ?? "";
    message.stableAsset = object.stableAsset ?? "";
    message.stableAmount = object.stableAmount ?? "";
    message.nhbAmount = object.nhbAmount ?? "";
    message.account = object.account ?? "";
    message.memo = object.memo ?? "";
    message.createdAt = object.createdAt ?? 0;
    return message;
  },
};

function createBaseCashOutIntent(): CashOutIntent {
  return {
    intentId: "",
    invoiceId: "",
    account: "",
    stableAsset: "",
    stableAmount: "",
    nhbAmount: "",
    status: "",
    createdAt: 0,
    settledAt: 0,
  };
}

export const CashOutIntent: MessageFns<CashOutIntent> = {
  encode(message: CashOutIntent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.intentId !== "") {
      writer.uint32(10).string(message.intentId);
    }
    if (message.invoiceId !== "") {
      writer.uint32(18).string(message.invoiceId);
    }
    if (message.account !== "") {
      writer.uint32(26).string(message.account);
    }
    if (message.stableAsset !== "") {
      writer.uint32(34).string(message.stableAsset);
    }
    if (message.stableAmount !== "") {
      writer.uint32(42).string(message.stableAmount);
    }
    if (message.nhbAmount !== "") {
      writer.uint32(50).string(message.nhbAmount);
    }
    if (message.status !== "") {
      writer.uint32(58).string(message.status);
    }
    if (message.createdAt !== 0) {
      writer.uint32(64).int64(message.createdAt);
    }
    if (message.settledAt !== 0) {
      writer.uint32(72).int64(message.settledAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CashOutIntent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCashOutIntent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.intentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.invoiceId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.account = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.stableAsset = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.stableAmount = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.nhbAmount = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.createdAt = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.settledAt = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CashOutIntent {
    return {
      intentId: isSet(object.intentId) ? globalThis.String(object.intentId) : "",
      invoiceId: isSet(object.invoiceId) ? globalThis.String(object.invoiceId) : "",
      account: isSet(object.account) ? globalThis.String(object.account) : "",
      stableAsset: isSet(object.stableAsset) ? globalThis.String(object.stableAsset) : "",
      stableAmount: isSet(object.stableAmount) ? globalThis.String(object.stableAmount) : "",
      nhbAmount: isSet(object.nhbAmount) ? globalThis.String(object.nhbAmount) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      settledAt: isSet(object.settledAt) ? globalThis.Number(object.settledAt) : 0,
    };
  },

  toJSON(message: CashOutIntent): unknown {
    const obj: any = {};
    if (message.intentId !== "") {
      obj.intentId = message.intentId;
    }
    if (message.invoiceId !== "") {
      obj.invoiceId = message.invoiceId;
    }
    if (message.account !== "") {
      obj.account = message.account;
    }
    if (message.stableAsset !== "") {
      obj.stableAsset = message.stableAsset;
    }
    if (message.stableAmount !== "") {
      obj.stableAmount = message.stableAmount;
    }
    if (message.nhbAmount !== "") {
      obj.nhbAmount = message.nhbAmount;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.settledAt !== 0) {
      obj.settledAt = Math.round(message.settledAt);
    }
    return obj;
  },

  create(base?: DeepPartial<CashOutIntent>): CashOutIntent {
    return CashOutIntent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CashOutIntent>): CashOutIntent {
    const message = createBaseCashOutIntent();
    message.intentId = object.intentId ?? "";
    message.invoiceId = object.invoiceId ?? "";
    message.account = object.account ?? "";
    message.stableAsset = object.stableAsset ?? "";
    message.stableAmount = object.stableAmount ?? "";
    message.nhbAmount = object.nhbAmount ?? "";
    message.status = object.status ?? "";
    message.createdAt = object.createdAt ?? 0;
    message.settledAt = object.settledAt ?? 0;
    return message;
  },
};

function createBaseEscrowLock(): EscrowLock {
  return { lockId: "", intentId: "", account: "", nhbAmount: "", burned: false, lockedAt: 0, burnedAt: 0 };
}

export const EscrowLock: MessageFns<EscrowLock> = {
  encode(message: EscrowLock, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lockId !== "") {
      writer.uint32(10).string(message.lockId);
    }
    if (message.intentId !== "") {
      writer.uint32(18).string(message.intentId);
    }
    if (message.account !== "") {
      writer.uint32(26).string(message.account);
    }
    if (message.nhbAmount !== "") {
      writer.uint32(34).string(message.nhbAmount);
    }
    if (message.burned !== false) {
      writer.uint32(40).bool(message.burned);
    }
    if (message.lockedAt !== 0) {
      writer.uint32(48).int64(message.lockedAt);
    }
    if (message.burnedAt !== 0) {
      writer.uint32(56).int64(message.burnedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EscrowLock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEscrowLock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.lockId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.intentId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.account = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nhbAmount = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.burned = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.lockedAt = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.burnedAt = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EscrowLock {
    return {
      lockId: isSet(object.lockId) ? globalThis.String(object.lockId) : "",
      intentId: isSet(object.intentId) ? globalThis.String(object.intentId) : "",
      account: isSet(object.account) ? globalThis.String(object.account) : "",
      nhbAmount: isSet(object.nhbAmount) ? globalThis.String(object.nhbAmount) : "",
      burned: isSet(object.burned) ? globalThis.Boolean(object.burned) : false,
      lockedAt: isSet(object.lockedAt) ? globalThis.Number(object.lockedAt) : 0,
      burnedAt: isSet(object.burnedAt) ? globalThis.Number(object.burnedAt) : 0,
    };
  },

  toJSON(message: EscrowLock): unknown {
    const obj: any = {};
    if (message.lockId !== "") {
      obj.lockId = message.lockId;
    }
    if (message.intentId !== "") {
      obj.intentId = message.intentId;
    }
    if (message.account !== "") {
      obj.account = message.account;
    }
    if (message.nhbAmount !== "") {
      obj.nhbAmount = message.nhbAmount;
    }
    if (message.burned !== false) {
      obj.burned = message.burned;
    }
    if (message.lockedAt !== 0) {
      obj.lockedAt = Math.round(message.lockedAt);
    }
    if (message.burnedAt !== 0) {
      obj.burnedAt = Math.round(message.burnedAt);
    }
    return obj;
  },

  create(base?: DeepPartial<EscrowLock>): EscrowLock {
    return EscrowLock.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EscrowLock>): EscrowLock {
    const message = createBaseEscrowLock();
    message.lockId = object.lockId ?? "";
    message.intentId = object.intentId ?? "";
    message.account = object.account ?? "";
    message.nhbAmount = object.nhbAmount ?? "";
    message.burned = object.burned ?? false;
    message.lockedAt = object.lockedAt ?? 0;
    message.burnedAt = object.burnedAt ?? 0;
    return message;
  },
};

function createBasePayoutReceipt(): PayoutReceipt {
  return {
    receiptId: "",
    intentId: "",
    stableAsset: "",
    stableAmount: "",
    nhbAmount: "",
    txHash: "",
    evidenceUri: "",
    settledAt: 0,
  };
}

export const PayoutReceipt: MessageFns<PayoutReceipt> = {
  encode(message: PayoutReceipt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.receiptId !== "") {
      writer.uint32(10).string(message.receiptId);
    }
    if (message.intentId !== "") {
      writer.uint32(18).string(message.intentId);
    }
    if (message.stableAsset !== "") {
      writer.uint32(26).string(message.stableAsset);
    }
    if (message.stableAmount !== "") {
      writer.uint32(34).string(message.stableAmount);
    }
    if (message.nhbAmount !== "") {
      writer.uint32(42).string(message.nhbAmount);
    }
    if (message.txHash !== "") {
      writer.uint32(50).string(message.txHash);
    }
    if (message.evidenceUri !== "") {
      writer.uint32(58).string(message.evidenceUri);
    }
    if (message.settledAt !== 0) {
      writer.uint32(64).int64(message.settledAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayoutReceipt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayoutReceipt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.receiptId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.intentId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.stableAsset = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.stableAmount = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nhbAmount = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.txHash = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.evidenceUri = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.settledAt = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayoutReceipt {
    return {
      receiptId: isSet(object.receiptId) ? globalThis.String(object.receiptId) : "",
      intentId: isSet(object.intentId) ? globalThis.String(object.intentId) : "",
      stableAsset: isSet(object.stableAsset) ? globalThis.String(object.stableAsset) : "",
      stableAmount: isSet(object.stableAmount) ? globalThis.String(object.stableAmount) : "",
      nhbAmount: isSet(object.nhbAmount) ? globalThis.String(object.nhbAmount) : "",
      txHash: isSet(object.txHash) ? globalThis.String(object.txHash) : "",
      evidenceUri: isSet(object.evidenceUri) ? globalThis.String(object.evidenceUri) : "",
      settledAt: isSet(object.settledAt) ? globalThis.Number(object.settledAt) : 0,
    };
  },

  toJSON(message: PayoutReceipt): unknown {
    const obj: any = {};
    if (message.receiptId !== "") {
      obj.receiptId = message.receiptId;
    }
    if (message.intentId !== "") {
      obj.intentId = message.intentId;
    }
    if (message.stableAsset !== "") {
      obj.stableAsset = message.stableAsset;
    }
    if (message.stableAmount !== "") {
      obj.stableAmount = message.stableAmount;
    }
    if (message.nhbAmount !== "") {
      obj.nhbAmount = message.nhbAmount;
    }
    if (message.txHash !== "") {
      obj.txHash = message.txHash;
    }
    if (message.evidenceUri !== "") {
      obj.evidenceUri = message.evidenceUri;
    }
    if (message.settledAt !== 0) {
      obj.settledAt = Math.round(message.settledAt);
    }
    return obj;
  },

  create(base?: DeepPartial<PayoutReceipt>): PayoutReceipt {
    return PayoutReceipt.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PayoutReceipt>): PayoutReceipt {
    const message = createBasePayoutReceipt();
    message.receiptId = object.receiptId ?? "";
    message.intentId = object.intentId ?? "";
    message.stableAsset = object.stableAsset ?? "";
    message.stableAmount = object.stableAmount ?? "";
    message.nhbAmount = object.nhbAmount ?? "";
    message.txHash = object.txHash ?? "";
    message.evidenceUri = object.evidenceUri ?? "";
    message.settledAt = object.settledAt ?? 0;
    return message;
  },
};

function createBaseTreasurySoftInventory(): TreasurySoftInventory {
  return { stableAsset: "", deposits: "", payouts: "", balance: "", updatedAt: 0 };
}

export const TreasurySoftInventory: MessageFns<TreasurySoftInventory> = {
  encode(message: TreasurySoftInventory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stableAsset !== "") {
      writer.uint32(10).string(message.stableAsset);
    }
    if (message.deposits !== "") {
      writer.uint32(18).string(message.deposits);
    }
    if (message.payouts !== "") {
      writer.uint32(26).string(message.payouts);
    }
    if (message.balance !== "") {
      writer.uint32(34).string(message.balance);
    }
    if (message.updatedAt !== 0) {
      writer.uint32(40).int64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TreasurySoftInventory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTreasurySoftInventory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stableAsset = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.deposits = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.payouts = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.balance = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.updatedAt = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TreasurySoftInventory {
    return {
      stableAsset: isSet(object.stableAsset) ? globalThis.String(object.stableAsset) : "",
      deposits: isSet(object.deposits) ? globalThis.String(object.deposits) : "",
      payouts: isSet(object.payouts) ? globalThis.String(object.payouts) : "",
      balance: isSet(object.balance) ? globalThis.String(object.balance) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.Number(object.updatedAt) : 0,
    };
  },

  toJSON(message: TreasurySoftInventory): unknown {
    const obj: any = {};
    if (message.stableAsset !== "") {
      obj.stableAsset = message.stableAsset;
    }
    if (message.deposits !== "") {
      obj.deposits = message.deposits;
    }
    if (message.payouts !== "") {
      obj.payouts = message.payouts;
    }
    if (message.balance !== "") {
      obj.balance = message.balance;
    }
    if (message.updatedAt !== 0) {
      obj.updatedAt = Math.round(message.updatedAt);
    }
    return obj;
  },

  create(base?: DeepPartial<TreasurySoftInventory>): TreasurySoftInventory {
    return TreasurySoftInventory.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TreasurySoftInventory>): TreasurySoftInventory {
    const message = createBaseTreasurySoftInventory();
    message.stableAsset = object.stableAsset ?? "";
    message.deposits = object.deposits ?? "";
    message.payouts = object.payouts ?? "";
    message.balance = object.balance ?? "";
    message.updatedAt = object.updatedAt ?? 0;
    return message;
  },
};

function createBaseQueryDepositVoucherRequest(): QueryDepositVoucherRequest {
  return { invoiceId: "" };
}

export const QueryDepositVoucherRequest: MessageFns<QueryDepositVoucherRequest> = {
  encode(message: QueryDepositVoucherRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.invoiceId !== "") {
      writer.uint32(10).string(message.invoiceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryDepositVoucherRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryDepositVoucherRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.invoiceId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryDepositVoucherRequest {
    return { invoiceId: isSet(object.invoiceId) ? globalThis.String(object.invoiceId) : "" };
  },

  toJSON(message: QueryDepositVoucherRequest): unknown {
    const obj: any = {};
    if (message.invoiceId !== "") {
      obj.invoiceId = message.invoiceId;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryDepositVoucherRequest>): QueryDepositVoucherRequest {
    return QueryDepositVoucherRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryDepositVoucherRequest>): QueryDepositVoucherRequest {
    const message = createBaseQueryDepositVoucherRequest();
    message.invoiceId = object.invoiceId ?? "";
    return message;
  },
};

function createBaseQueryDepositVoucherResponse(): QueryDepositVoucherResponse {
  return { voucher: undefined };
}

export const QueryDepositVoucherResponse: MessageFns<QueryDepositVoucherResponse> = {
  encode(message: QueryDepositVoucherResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.voucher !== undefined) {
      DepositVoucher.encode(message.voucher, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryDepositVoucherResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryDepositVoucherResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.voucher = DepositVoucher.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryDepositVoucherResponse {
    return { voucher: isSet(object.voucher) ? DepositVoucher.fromJSON(object.voucher) : undefined };
  },

  toJSON(message: QueryDepositVoucherResponse): unknown {
    const obj: any = {};
    if (message.voucher !== undefined) {
      obj.voucher = DepositVoucher.toJSON(message.voucher);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryDepositVoucherResponse>): QueryDepositVoucherResponse {
    return QueryDepositVoucherResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryDepositVoucherResponse>): QueryDepositVoucherResponse {
    const message = createBaseQueryDepositVoucherResponse();
    message.voucher = (object.voucher !== undefined && object.voucher !== null)
      ? DepositVoucher.fromPartial(object.voucher)
      : undefined;
    return message;
  },
};

function createBaseQueryCashOutIntentRequest(): QueryCashOutIntentRequest {
  return { intentId: "" };
}

export const QueryCashOutIntentRequest: MessageFns<QueryCashOutIntentRequest> = {
  encode(message: QueryCashOutIntentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.intentId !== "") {
      writer.uint32(10).string(message.intentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryCashOutIntentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCashOutIntentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.intentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryCashOutIntentRequest {
    return { intentId: isSet(object.intentId) ? globalThis.String(object.intentId) : "" };
  },

  toJSON(message: QueryCashOutIntentRequest): unknown {
    const obj: any = {};
    if (message.intentId !== "") {
      obj.intentId = message.intentId;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryCashOutIntentRequest>): QueryCashOutIntentRequest {
    return QueryCashOutIntentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryCashOutIntentRequest>): QueryCashOutIntentRequest {
    const message = createBaseQueryCashOutIntentRequest();
    message.intentId = object.intentId ?? "";
    return message;
  },
};

function createBaseQueryCashOutIntentResponse(): QueryCashOutIntentResponse {
  return { intent: undefined, lock: undefined, receipt: undefined };
}

export const QueryCashOutIntentResponse: MessageFns<QueryCashOutIntentResponse> = {
  encode(message: QueryCashOutIntentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.intent !== undefined) {
      CashOutIntent.encode(message.intent, writer.uint32(10).fork()).join();
    }
    if (message.lock !== undefined) {
      EscrowLock.encode(message.lock, writer.uint32(18).fork()).join();
    }
    if (message.receipt !== undefined) {
      PayoutReceipt.encode(message.receipt, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryCashOutIntentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCashOutIntentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.intent = CashOutIntent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.lock = EscrowLock.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.receipt = PayoutReceipt.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryCashOutIntentResponse {
    return {
      intent: isSet(object.intent) ? CashOutIntent.fromJSON(object.intent) : undefined,
      lock: isSet(object.lock) ? EscrowLock.fromJSON(object.lock) : undefined,
      receipt: isSet(object.receipt) ? PayoutReceipt.fromJSON(object.receipt) : undefined,
    };
  },

  toJSON(message: QueryCashOutIntentResponse): unknown {
    const obj: any = {};
    if (message.intent !== undefined) {
      obj.intent = CashOutIntent.toJSON(message.intent);
    }
    if (message.lock !== undefined) {
      obj.lock = EscrowLock.toJSON(message.lock);
    }
    if (message.receipt !== undefined) {
      obj.receipt = PayoutReceipt.toJSON(message.receipt);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryCashOutIntentResponse>): QueryCashOutIntentResponse {
    return QueryCashOutIntentResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryCashOutIntentResponse>): QueryCashOutIntentResponse {
    const message = createBaseQueryCashOutIntentResponse();
    message.intent = (object.intent !== undefined && object.intent !== null)
      ? CashOutIntent.fromPartial(object.intent)
      : undefined;
    message.lock = (object.lock !== undefined && object.lock !== null)
      ? EscrowLock.fromPartial(object.lock)
      : undefined;
    message.receipt = (object.receipt !== undefined && object.receipt !== null)
      ? PayoutReceipt.fromPartial(object.receipt)
      : undefined;
    return message;
  },
};

function createBaseQuerySoftInventoryRequest(): QuerySoftInventoryRequest {
  return { stableAsset: "" };
}

export const QuerySoftInventoryRequest: MessageFns<QuerySoftInventoryRequest> = {
  encode(message: QuerySoftInventoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stableAsset !== "") {
      writer.uint32(10).string(message.stableAsset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuerySoftInventoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySoftInventoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stableAsset = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySoftInventoryRequest {
    return { stableAsset: isSet(object.stableAsset) ? globalThis.String(object.stableAsset) : "" };
  },

  toJSON(message: QuerySoftInventoryRequest): unknown {
    const obj: any = {};
    if (message.stableAsset !== "") {
      obj.stableAsset = message.stableAsset;
    }
    return obj;
  },

  create(base?: DeepPartial<QuerySoftInventoryRequest>): QuerySoftInventoryRequest {
    return QuerySoftInventoryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QuerySoftInventoryRequest>): QuerySoftInventoryRequest {
    const message = createBaseQuerySoftInventoryRequest();
    message.stableAsset = object.stableAsset ?? "";
    return message;
  },
};

function createBaseQuerySoftInventoryResponse(): QuerySoftInventoryResponse {
  return { inventory: undefined };
}

export const QuerySoftInventoryResponse: MessageFns<QuerySoftInventoryResponse> = {
  encode(message: QuerySoftInventoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inventory !== undefined) {
      TreasurySoftInventory.encode(message.inventory, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuerySoftInventoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySoftInventoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inventory = TreasurySoftInventory.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySoftInventoryResponse {
    return { inventory: isSet(object.inventory) ? TreasurySoftInventory.fromJSON(object.inventory) : undefined };
  },

  toJSON(message: QuerySoftInventoryResponse): unknown {
    const obj: any = {};
    if (message.inventory !== undefined) {
      obj.inventory = TreasurySoftInventory.toJSON(message.inventory);
    }
    return obj;
  },

  create(base?: DeepPartial<QuerySoftInventoryResponse>): QuerySoftInventoryResponse {
    return QuerySoftInventoryResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QuerySoftInventoryResponse>): QuerySoftInventoryResponse {
    const message = createBaseQuerySoftInventoryResponse();
    message.inventory = (object.inventory !== undefined && object.inventory !== null)
      ? TreasurySoftInventory.fromPartial(object.inventory)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}

// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               unknown
// source: swap/v1/swap.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "swap.v1";

export interface PoolKey {
  base: string;
  quote: string;
}

export interface Pool {
  key: PoolKey | undefined;
  baseReserve: string;
  quoteReserve: string;
  swapFee: string;
  protocolFee: string;
}

export interface GetPoolRequest {
  key: PoolKey | undefined;
}

export interface GetPoolResponse {
  pool: Pool | undefined;
}

export interface ListPoolsRequest {
}

export interface ListPoolsResponse {
  pools: Pool[];
}

export interface SwapExactInRequest {
  key: PoolKey | undefined;
  trader: string;
  amountIn: string;
  minAmountOut: string;
}

export interface SwapExactInResponse {
  amountOut: string;
}

export interface SwapExactOutRequest {
  key: PoolKey | undefined;
  trader: string;
  maxAmountIn: string;
  amountOut: string;
}

export interface SwapExactOutResponse {
  amountIn: string;
}

function createBasePoolKey(): PoolKey {
  return { base: "", quote: "" };
}

export const PoolKey: MessageFns<PoolKey> = {
  encode(message: PoolKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.base !== "") {
      writer.uint32(10).string(message.base);
    }
    if (message.quote !== "") {
      writer.uint32(18).string(message.quote);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PoolKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePoolKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.base = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.quote = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PoolKey {
    return {
      base: isSet(object.base) ? globalThis.String(object.base) : "",
      quote: isSet(object.quote) ? globalThis.String(object.quote) : "",
    };
  },

  toJSON(message: PoolKey): unknown {
    const obj: any = {};
    if (message.base !== "") {
      obj.base = message.base;
    }
    if (message.quote !== "") {
      obj.quote = message.quote;
    }
    return obj;
  },

  create(base?: DeepPartial<PoolKey>): PoolKey {
    return PoolKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PoolKey>): PoolKey {
    const message = createBasePoolKey();
    message.base = object.base ?? "";
    message.quote = object.quote ?? "";
    return message;
  },
};

function createBasePool(): Pool {
  return { key: undefined, baseReserve: "", quoteReserve: "", swapFee: "", protocolFee: "" };
}

export const Pool: MessageFns<Pool> = {
  encode(message: Pool, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      PoolKey.encode(message.key, writer.uint32(10).fork()).join();
    }
    if (message.baseReserve !== "") {
      writer.uint32(18).string(message.baseReserve);
    }
    if (message.quoteReserve !== "") {
      writer.uint32(26).string(message.quoteReserve);
    }
    if (message.swapFee !== "") {
      writer.uint32(34).string(message.swapFee);
    }
    if (message.protocolFee !== "") {
      writer.uint32(42).string(message.protocolFee);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pool {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = PoolKey.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.baseReserve = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.quoteReserve = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.swapFee = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.protocolFee = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Pool {
    return {
      key: isSet(object.key) ? PoolKey.fromJSON(object.key) : undefined,
      baseReserve: isSet(object.baseReserve) ? globalThis.String(object.baseReserve) : "",
      quoteReserve: isSet(object.quoteReserve) ? globalThis.String(object.quoteReserve) : "",
      swapFee: isSet(object.swapFee) ? globalThis.String(object.swapFee) : "",
      protocolFee: isSet(object.protocolFee) ? globalThis.String(object.protocolFee) : "",
    };
  },

  toJSON(message: Pool): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = PoolKey.toJSON(message.key);
    }
    if (message.baseReserve !== "") {
      obj.baseReserve = message.baseReserve;
    }
    if (message.quoteReserve !== "") {
      obj.quoteReserve = message.quoteReserve;
    }
    if (message.swapFee !== "") {
      obj.swapFee = message.swapFee;
    }
    if (message.protocolFee !== "") {
      obj.protocolFee = message.protocolFee;
    }
    return obj;
  },

  create(base?: DeepPartial<Pool>): Pool {
    return Pool.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Pool>): Pool {
    const message = createBasePool();
    message.key = (object.key !== undefined && object.key !== null) ? PoolKey.fromPartial(object.key) : undefined;
    message.baseReserve = object.baseReserve ?? "";
    message.quoteReserve = object.quoteReserve ?? "";
    message.swapFee = object.swapFee ?? "";
    message.protocolFee = object.protocolFee ?? "";
    return message;
  },
};

function createBaseGetPoolRequest(): GetPoolRequest {
  return { key: undefined };
}

export const GetPoolRequest: MessageFns<GetPoolRequest> = {
  encode(message: GetPoolRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      PoolKey.encode(message.key, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPoolRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPoolRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = PoolKey.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPoolRequest {
    return { key: isSet(object.key) ? PoolKey.fromJSON(object.key) : undefined };
  },

  toJSON(message: GetPoolRequest): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = PoolKey.toJSON(message.key);
    }
    return obj;
  },

  create(base?: DeepPartial<GetPoolRequest>): GetPoolRequest {
    return GetPoolRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetPoolRequest>): GetPoolRequest {
    const message = createBaseGetPoolRequest();
    message.key = (object.key !== undefined && object.key !== null) ? PoolKey.fromPartial(object.key) : undefined;
    return message;
  },
};

function createBaseGetPoolResponse(): GetPoolResponse {
  return { pool: undefined };
}

export const GetPoolResponse: MessageFns<GetPoolResponse> = {
  encode(message: GetPoolResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pool !== undefined) {
      Pool.encode(message.pool, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPoolResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPoolResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pool = Pool.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPoolResponse {
    return { pool: isSet(object.pool) ? Pool.fromJSON(object.pool) : undefined };
  },

  toJSON(message: GetPoolResponse): unknown {
    const obj: any = {};
    if (message.pool !== undefined) {
      obj.pool = Pool.toJSON(message.pool);
    }
    return obj;
  },

  create(base?: DeepPartial<GetPoolResponse>): GetPoolResponse {
    return GetPoolResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetPoolResponse>): GetPoolResponse {
    const message = createBaseGetPoolResponse();
    message.pool = (object.pool !== undefined && object.pool !== null) ? Pool.fromPartial(object.pool) : undefined;
    return message;
  },
};

function createBaseListPoolsRequest(): ListPoolsRequest {
  return {};
}

export const ListPoolsRequest: MessageFns<ListPoolsRequest> = {
  encode(_: ListPoolsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPoolsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPoolsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListPoolsRequest {
    return {};
  },

  toJSON(_: ListPoolsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ListPoolsRequest>): ListPoolsRequest {
    return ListPoolsRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ListPoolsRequest>): ListPoolsRequest {
    const message = createBaseListPoolsRequest();
    return message;
  },
};

function createBaseListPoolsResponse(): ListPoolsResponse {
  return { pools: [] };
}

export const ListPoolsResponse: MessageFns<ListPoolsResponse> = {
  encode(message: ListPoolsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.pools) {
      Pool.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPoolsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPoolsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pools.push(Pool.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPoolsResponse {
    return { pools: globalThis.Array.isArray(object?.pools) ? object.pools.map((e: any) => Pool.fromJSON(e)) : [] };
  },

  toJSON(message: ListPoolsResponse): unknown {
    const obj: any = {};
    if (message.pools?.length) {
      obj.pools = message.pools.map((e) => Pool.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListPoolsResponse>): ListPoolsResponse {
    return ListPoolsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPoolsResponse>): ListPoolsResponse {
    const message = createBaseListPoolsResponse();
    message.pools = object.pools?.map((e) => Pool.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSwapExactInRequest(): SwapExactInRequest {
  return { key: undefined, trader: "", amountIn: "", minAmountOut: "" };
}

export const SwapExactInRequest: MessageFns<SwapExactInRequest> = {
  encode(message: SwapExactInRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      PoolKey.encode(message.key, writer.uint32(10).fork()).join();
    }
    if (message.trader !== "") {
      writer.uint32(18).string(message.trader);
    }
    if (message.amountIn !== "") {
      writer.uint32(26).string(message.amountIn);
    }
    if (message.minAmountOut !== "") {
      writer.uint32(34).string(message.minAmountOut);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SwapExactInRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwapExactInRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = PoolKey.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.trader = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amountIn = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.minAmountOut = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SwapExactInRequest {
    return {
      key: isSet(object.key) ? PoolKey.fromJSON(object.key) : undefined,
      trader: isSet(object.trader) ? globalThis.String(object.trader) : "",
      amountIn: isSet(object.amountIn) ? globalThis.String(object.amountIn) : "",
      minAmountOut: isSet(object.minAmountOut) ? globalThis.String(object.minAmountOut) : "",
    };
  },

  toJSON(message: SwapExactInRequest): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = PoolKey.toJSON(message.key);
    }
    if (message.trader !== "") {
      obj.trader = message.trader;
    }
    if (message.amountIn !== "") {
      obj.amountIn = message.amountIn;
    }
    if (message.minAmountOut !== "") {
      obj.minAmountOut = message.minAmountOut;
    }
    return obj;
  },

  create(base?: DeepPartial<SwapExactInRequest>): SwapExactInRequest {
    return SwapExactInRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SwapExactInRequest>): SwapExactInRequest {
    const message = createBaseSwapExactInRequest();
    message.key = (object.key !== undefined && object.key !== null) ? PoolKey.fromPartial(object.key) : undefined;
    message.trader = object.trader ?? "";
    message.amountIn = object.amountIn ?? "";
    message.minAmountOut = object.minAmountOut ?? "";
    return message;
  },
};

function createBaseSwapExactInResponse(): SwapExactInResponse {
  return { amountOut: "" };
}

export const SwapExactInResponse: MessageFns<SwapExactInResponse> = {
  encode(message: SwapExactInResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amountOut !== "") {
      writer.uint32(10).string(message.amountOut);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SwapExactInResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwapExactInResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amountOut = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SwapExactInResponse {
    return { amountOut: isSet(object.amountOut) ? globalThis.String(object.amountOut) : "" };
  },

  toJSON(message: SwapExactInResponse): unknown {
    const obj: any = {};
    if (message.amountOut !== "") {
      obj.amountOut = message.amountOut;
    }
    return obj;
  },

  create(base?: DeepPartial<SwapExactInResponse>): SwapExactInResponse {
    return SwapExactInResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SwapExactInResponse>): SwapExactInResponse {
    const message = createBaseSwapExactInResponse();
    message.amountOut = object.amountOut ?? "";
    return message;
  },
};

function createBaseSwapExactOutRequest(): SwapExactOutRequest {
  return { key: undefined, trader: "", maxAmountIn: "", amountOut: "" };
}

export const SwapExactOutRequest: MessageFns<SwapExactOutRequest> = {
  encode(message: SwapExactOutRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      PoolKey.encode(message.key, writer.uint32(10).fork()).join();
    }
    if (message.trader !== "") {
      writer.uint32(18).string(message.trader);
    }
    if (message.maxAmountIn !== "") {
      writer.uint32(26).string(message.maxAmountIn);
    }
    if (message.amountOut !== "") {
      writer.uint32(34).string(message.amountOut);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SwapExactOutRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwapExactOutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = PoolKey.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.trader = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.maxAmountIn = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amountOut = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SwapExactOutRequest {
    return {
      key: isSet(object.key) ? PoolKey.fromJSON(object.key) : undefined,
      trader: isSet(object.trader) ? globalThis.String(object.trader) : "",
      maxAmountIn: isSet(object.maxAmountIn) ? globalThis.String(object.maxAmountIn) : "",
      amountOut: isSet(object.amountOut) ? globalThis.String(object.amountOut) : "",
    };
  },

  toJSON(message: SwapExactOutRequest): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = PoolKey.toJSON(message.key);
    }
    if (message.trader !== "") {
      obj.trader = message.trader;
    }
    if (message.maxAmountIn !== "") {
      obj.maxAmountIn = message.maxAmountIn;
    }
    if (message.amountOut !== "") {
      obj.amountOut = message.amountOut;
    }
    return obj;
  },

  create(base?: DeepPartial<SwapExactOutRequest>): SwapExactOutRequest {
    return SwapExactOutRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SwapExactOutRequest>): SwapExactOutRequest {
    const message = createBaseSwapExactOutRequest();
    message.key = (object.key !== undefined && object.key !== null) ? PoolKey.fromPartial(object.key) : undefined;
    message.trader = object.trader ?? "";
    message.maxAmountIn = object.maxAmountIn ?? "";
    message.amountOut = object.amountOut ?? "";
    return message;
  },
};

function createBaseSwapExactOutResponse(): SwapExactOutResponse {
  return { amountIn: "" };
}

export const SwapExactOutResponse: MessageFns<SwapExactOutResponse> = {
  encode(message: SwapExactOutResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amountIn !== "") {
      writer.uint32(10).string(message.amountIn);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SwapExactOutResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwapExactOutResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amountIn = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SwapExactOutResponse {
    return { amountIn: isSet(object.amountIn) ? globalThis.String(object.amountIn) : "" };
  },

  toJSON(message: SwapExactOutResponse): unknown {
    const obj: any = {};
    if (message.amountIn !== "") {
      obj.amountIn = message.amountIn;
    }
    return obj;
  },

  create(base?: DeepPartial<SwapExactOutResponse>): SwapExactOutResponse {
    return SwapExactOutResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SwapExactOutResponse>): SwapExactOutResponse {
    const message = createBaseSwapExactOutResponse();
    message.amountIn = object.amountIn ?? "";
    return message;
  },
};

export type SwapServiceService = typeof SwapServiceService;
export const SwapServiceService = {
  getPool: {
    path: "/swap.v1.SwapService/GetPool",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPoolRequest): Buffer => Buffer.from(GetPoolRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetPoolRequest => GetPoolRequest.decode(value),
    responseSerialize: (value: GetPoolResponse): Buffer => Buffer.from(GetPoolResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetPoolResponse => GetPoolResponse.decode(value),
  },
  listPools: {
    path: "/swap.v1.SwapService/ListPools",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListPoolsRequest): Buffer => Buffer.from(ListPoolsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListPoolsRequest => ListPoolsRequest.decode(value),
    responseSerialize: (value: ListPoolsResponse): Buffer => Buffer.from(ListPoolsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListPoolsResponse => ListPoolsResponse.decode(value),
  },
  swapExactIn: {
    path: "/swap.v1.SwapService/SwapExactIn",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SwapExactInRequest): Buffer => Buffer.from(SwapExactInRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SwapExactInRequest => SwapExactInRequest.decode(value),
    responseSerialize: (value: SwapExactInResponse): Buffer => Buffer.from(SwapExactInResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SwapExactInResponse => SwapExactInResponse.decode(value),
  },
  swapExactOut: {
    path: "/swap.v1.SwapService/SwapExactOut",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SwapExactOutRequest): Buffer => Buffer.from(SwapExactOutRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SwapExactOutRequest => SwapExactOutRequest.decode(value),
    responseSerialize: (value: SwapExactOutResponse): Buffer =>
      Buffer.from(SwapExactOutResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SwapExactOutResponse => SwapExactOutResponse.decode(value),
  },
} as const;

export interface SwapServiceServer extends UntypedServiceImplementation {
  getPool: handleUnaryCall<GetPoolRequest, GetPoolResponse>;
  listPools: handleUnaryCall<ListPoolsRequest, ListPoolsResponse>;
  swapExactIn: handleUnaryCall<SwapExactInRequest, SwapExactInResponse>;
  swapExactOut: handleUnaryCall<SwapExactOutRequest, SwapExactOutResponse>;
}

export interface SwapServiceClient extends Client {
  getPool(
    request: GetPoolRequest,
    callback: (error: ServiceError | null, response: GetPoolResponse) => void,
  ): ClientUnaryCall;
  getPool(
    request: GetPoolRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetPoolResponse) => void,
  ): ClientUnaryCall;
  getPool(
    request: GetPoolRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetPoolResponse) => void,
  ): ClientUnaryCall;
  listPools(
    request: ListPoolsRequest,
    callback: (error: ServiceError | null, response: ListPoolsResponse) => void,
  ): ClientUnaryCall;
  listPools(
    request: ListPoolsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListPoolsResponse) => void,
  ): ClientUnaryCall;
  listPools(
    request: ListPoolsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListPoolsResponse) => void,
  ): ClientUnaryCall;
  swapExactIn(
    request: SwapExactInRequest,
    callback: (error: ServiceError | null, response: SwapExactInResponse) => void,
  ): ClientUnaryCall;
  swapExactIn(
    request: SwapExactInRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SwapExactInResponse) => void,
  ): ClientUnaryCall;
  swapExactIn(
    request: SwapExactInRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SwapExactInResponse) => void,
  ): ClientUnaryCall;
  swapExactOut(
    request: SwapExactOutRequest,
    callback: (error: ServiceError | null, response: SwapExactOutResponse) => void,
  ): ClientUnaryCall;
  swapExactOut(
    request: SwapExactOutRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SwapExactOutResponse) => void,
  ): ClientUnaryCall;
  swapExactOut(
    request: SwapExactOutRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SwapExactOutResponse) => void,
  ): ClientUnaryCall;
}

export const SwapServiceClient = makeGenericClientConstructor(SwapServiceService, "swap.v1.SwapService") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): SwapServiceClient;
  service: typeof SwapServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}

// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               unknown
// source: consensus/v1/consensus.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { SubmitTxEnvelopeRequest, SubmitTxEnvelopeResponse } from "./tx";

export const protobufPackage = "consensus.v1";

export interface BigInt {
  value: string;
}

export interface Transaction {
  chainId: BigInt | undefined;
  type: number;
  nonce: number;
  to: Buffer;
  value: BigInt | undefined;
  data: Buffer;
  gasLimit: number;
  gasPrice: BigInt | undefined;
  paymaster: Buffer;
  r: BigInt | undefined;
  s: BigInt | undefined;
  v: BigInt | undefined;
  paymasterR: BigInt | undefined;
  paymasterS: BigInt | undefined;
  paymasterV: BigInt | undefined;
  intentRef: Buffer;
  intentExpiry: number;
  merchantAddr: string;
  deviceId: string;
  refundOf: string;
}

export interface BlockHeader {
  height: number;
  timestamp: number;
  prevHash: Buffer;
  stateRoot: Buffer;
  txRoot: Buffer;
  validator: Buffer;
}

export interface Block {
  header: BlockHeader | undefined;
  transactions: Transaction[];
}

export interface SubmitTransactionRequest {
  transaction: Transaction | undefined;
}

export interface SubmitTransactionResponse {
}

export interface GetValidatorSetRequest {
}

export interface Validator {
  address: Buffer;
  power: string;
}

export interface GetValidatorSetResponse {
  validators: Validator[];
}

export interface GetBlockByHeightRequest {
  height: number;
}

export interface GetBlockByHeightResponse {
  block: Block | undefined;
}

export interface GetHeightRequest {
}

export interface GetHeightResponse {
  height: number;
}

export interface GetMempoolRequest {
}

export interface GetMempoolResponse {
  transactions: Transaction[];
}

export interface CreateBlockRequest {
  transactions: Transaction[];
}

export interface CreateBlockResponse {
  block: Block | undefined;
}

export interface CommitBlockRequest {
  block: Block | undefined;
}

export interface CommitBlockResponse {
}

export interface GetLastCommitHashRequest {
}

export interface GetLastCommitHashResponse {
  hash: Buffer;
}

function createBaseBigInt(): BigInt {
  return { value: "" };
}

export const BigInt: MessageFns<BigInt> = {
  encode(message: BigInt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BigInt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBigInt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BigInt {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: BigInt): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<BigInt>): BigInt {
    return BigInt.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BigInt>): BigInt {
    const message = createBaseBigInt();
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTransaction(): Transaction {
  return {
    chainId: undefined,
    type: 0,
    nonce: 0,
    to: Buffer.alloc(0),
    value: undefined,
    data: Buffer.alloc(0),
    gasLimit: 0,
    gasPrice: undefined,
    paymaster: Buffer.alloc(0),
    r: undefined,
    s: undefined,
    v: undefined,
    paymasterR: undefined,
    paymasterS: undefined,
    paymasterV: undefined,
    intentRef: Buffer.alloc(0),
    intentExpiry: 0,
    merchantAddr: "",
    deviceId: "",
    refundOf: "",
  };
}

export const Transaction: MessageFns<Transaction> = {
  encode(message: Transaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== undefined) {
      BigInt.encode(message.chainId, writer.uint32(10).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(16).uint32(message.type);
    }
    if (message.nonce !== 0) {
      writer.uint32(24).uint64(message.nonce);
    }
    if (message.to.length !== 0) {
      writer.uint32(34).bytes(message.to);
    }
    if (message.value !== undefined) {
      BigInt.encode(message.value, writer.uint32(42).fork()).join();
    }
    if (message.data.length !== 0) {
      writer.uint32(50).bytes(message.data);
    }
    if (message.gasLimit !== 0) {
      writer.uint32(56).uint64(message.gasLimit);
    }
    if (message.gasPrice !== undefined) {
      BigInt.encode(message.gasPrice, writer.uint32(66).fork()).join();
    }
    if (message.paymaster.length !== 0) {
      writer.uint32(74).bytes(message.paymaster);
    }
    if (message.r !== undefined) {
      BigInt.encode(message.r, writer.uint32(82).fork()).join();
    }
    if (message.s !== undefined) {
      BigInt.encode(message.s, writer.uint32(90).fork()).join();
    }
    if (message.v !== undefined) {
      BigInt.encode(message.v, writer.uint32(98).fork()).join();
    }
    if (message.paymasterR !== undefined) {
      BigInt.encode(message.paymasterR, writer.uint32(106).fork()).join();
    }
    if (message.paymasterS !== undefined) {
      BigInt.encode(message.paymasterS, writer.uint32(114).fork()).join();
    }
    if (message.paymasterV !== undefined) {
      BigInt.encode(message.paymasterV, writer.uint32(122).fork()).join();
    }
    if (message.intentRef.length !== 0) {
      writer.uint32(130).bytes(message.intentRef);
    }
    if (message.intentExpiry !== 0) {
      writer.uint32(136).uint64(message.intentExpiry);
    }
    if (message.merchantAddr !== "") {
      writer.uint32(146).string(message.merchantAddr);
    }
    if (message.deviceId !== "") {
      writer.uint32(154).string(message.deviceId);
    }
    if (message.refundOf !== "") {
      writer.uint32(162).string(message.refundOf);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Transaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = BigInt.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.nonce = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.to = Buffer.from(reader.bytes());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.value = BigInt.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.data = Buffer.from(reader.bytes());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.gasLimit = longToNumber(reader.uint64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.gasPrice = BigInt.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.paymaster = Buffer.from(reader.bytes());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.r = BigInt.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.s = BigInt.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.v = BigInt.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.paymasterR = BigInt.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.paymasterS = BigInt.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.paymasterV = BigInt.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.intentRef = Buffer.from(reader.bytes());
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.intentExpiry = longToNumber(reader.uint64());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.merchantAddr = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.deviceId = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.refundOf = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Transaction {
    return {
      chainId: isSet(object.chainId) ? BigInt.fromJSON(object.chainId) : undefined,
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      nonce: isSet(object.nonce) ? globalThis.Number(object.nonce) : 0,
      to: isSet(object.to) ? Buffer.from(bytesFromBase64(object.to)) : Buffer.alloc(0),
      value: isSet(object.value) ? BigInt.fromJSON(object.value) : undefined,
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
      gasLimit: isSet(object.gasLimit) ? globalThis.Number(object.gasLimit) : 0,
      gasPrice: isSet(object.gasPrice) ? BigInt.fromJSON(object.gasPrice) : undefined,
      paymaster: isSet(object.paymaster) ? Buffer.from(bytesFromBase64(object.paymaster)) : Buffer.alloc(0),
      r: isSet(object.r) ? BigInt.fromJSON(object.r) : undefined,
      s: isSet(object.s) ? BigInt.fromJSON(object.s) : undefined,
      v: isSet(object.v) ? BigInt.fromJSON(object.v) : undefined,
      paymasterR: isSet(object.paymasterR) ? BigInt.fromJSON(object.paymasterR) : undefined,
      paymasterS: isSet(object.paymasterS) ? BigInt.fromJSON(object.paymasterS) : undefined,
      paymasterV: isSet(object.paymasterV) ? BigInt.fromJSON(object.paymasterV) : undefined,
      intentRef: isSet(object.intentRef) ? Buffer.from(bytesFromBase64(object.intentRef)) : Buffer.alloc(0),
      intentExpiry: isSet(object.intentExpiry) ? globalThis.Number(object.intentExpiry) : 0,
      merchantAddr: isSet(object.merchantAddr) ? globalThis.String(object.merchantAddr) : "",
      deviceId: isSet(object.deviceId) ? globalThis.String(object.deviceId) : "",
      refundOf: isSet(object.refundOf) ? globalThis.String(object.refundOf) : "",
    };
  },

  toJSON(message: Transaction): unknown {
    const obj: any = {};
    if (message.chainId !== undefined) {
      obj.chainId = BigInt.toJSON(message.chainId);
    }
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.nonce !== 0) {
      obj.nonce = Math.round(message.nonce);
    }
    if (message.to.length !== 0) {
      obj.to = base64FromBytes(message.to);
    }
    if (message.value !== undefined) {
      obj.value = BigInt.toJSON(message.value);
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.gasLimit !== 0) {
      obj.gasLimit = Math.round(message.gasLimit);
    }
    if (message.gasPrice !== undefined) {
      obj.gasPrice = BigInt.toJSON(message.gasPrice);
    }
    if (message.paymaster.length !== 0) {
      obj.paymaster = base64FromBytes(message.paymaster);
    }
    if (message.r !== undefined) {
      obj.r = BigInt.toJSON(message.r);
    }
    if (message.s !== undefined) {
      obj.s = BigInt.toJSON(message.s);
    }
    if (message.v !== undefined) {
      obj.v = BigInt.toJSON(message.v);
    }
    if (message.paymasterR !== undefined) {
      obj.paymasterR = BigInt.toJSON(message.paymasterR);
    }
    if (message.paymasterS !== undefined) {
      obj.paymasterS = BigInt.toJSON(message.paymasterS);
    }
    if (message.paymasterV !== undefined) {
      obj.paymasterV = BigInt.toJSON(message.paymasterV);
    }
    if (message.intentRef.length !== 0) {
      obj.intentRef = base64FromBytes(message.intentRef);
    }
    if (message.intentExpiry !== 0) {
      obj.intentExpiry = Math.round(message.intentExpiry);
    }
    if (message.merchantAddr !== "") {
      obj.merchantAddr = message.merchantAddr;
    }
    if (message.deviceId !== "") {
      obj.deviceId = message.deviceId;
    }
    if (message.refundOf !== "") {
      obj.refundOf = message.refundOf;
    }
    return obj;
  },

  create(base?: DeepPartial<Transaction>): Transaction {
    return Transaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Transaction>): Transaction {
    const message = createBaseTransaction();
    message.chainId = (object.chainId !== undefined && object.chainId !== null)
      ? BigInt.fromPartial(object.chainId)
      : undefined;
    message.type = object.type ?? 0;
    message.nonce = object.nonce ?? 0;
    message.to = object.to ?? Buffer.alloc(0);
    message.value = (object.value !== undefined && object.value !== null)
      ? BigInt.fromPartial(object.value)
      : undefined;
    message.data = object.data ?? Buffer.alloc(0);
    message.gasLimit = object.gasLimit ?? 0;
    message.gasPrice = (object.gasPrice !== undefined && object.gasPrice !== null)
      ? BigInt.fromPartial(object.gasPrice)
      : undefined;
    message.paymaster = object.paymaster ?? Buffer.alloc(0);
    message.r = (object.r !== undefined && object.r !== null) ? BigInt.fromPartial(object.r) : undefined;
    message.s = (object.s !== undefined && object.s !== null) ? BigInt.fromPartial(object.s) : undefined;
    message.v = (object.v !== undefined && object.v !== null) ? BigInt.fromPartial(object.v) : undefined;
    message.paymasterR = (object.paymasterR !== undefined && object.paymasterR !== null)
      ? BigInt.fromPartial(object.paymasterR)
      : undefined;
    message.paymasterS = (object.paymasterS !== undefined && object.paymasterS !== null)
      ? BigInt.fromPartial(object.paymasterS)
      : undefined;
    message.paymasterV = (object.paymasterV !== undefined && object.paymasterV !== null)
      ? BigInt.fromPartial(object.paymasterV)
      : undefined;
    message.intentRef = object.intentRef ?? Buffer.alloc(0);
    message.intentExpiry = object.intentExpiry ?? 0;
    message.merchantAddr = object.merchantAddr ?? "";
    message.deviceId = object.deviceId ?? "";
    message.refundOf = object.refundOf ?? "";
    return message;
  },
};

function createBaseBlockHeader(): BlockHeader {
  return {
    height: 0,
    timestamp: 0,
    prevHash: Buffer.alloc(0),
    stateRoot: Buffer.alloc(0),
    txRoot: Buffer.alloc(0),
    validator: Buffer.alloc(0),
  };
}

export const BlockHeader: MessageFns<BlockHeader> = {
  encode(message: BlockHeader, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.height !== 0) {
      writer.uint32(8).uint64(message.height);
    }
    if (message.timestamp !== 0) {
      writer.uint32(16).int64(message.timestamp);
    }
    if (message.prevHash.length !== 0) {
      writer.uint32(26).bytes(message.prevHash);
    }
    if (message.stateRoot.length !== 0) {
      writer.uint32(34).bytes(message.stateRoot);
    }
    if (message.txRoot.length !== 0) {
      writer.uint32(42).bytes(message.txRoot);
    }
    if (message.validator.length !== 0) {
      writer.uint32(50).bytes(message.validator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockHeader {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.height = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.timestamp = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.prevHash = Buffer.from(reader.bytes());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.stateRoot = Buffer.from(reader.bytes());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.txRoot = Buffer.from(reader.bytes());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.validator = Buffer.from(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockHeader {
    return {
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      prevHash: isSet(object.prevHash) ? Buffer.from(bytesFromBase64(object.prevHash)) : Buffer.alloc(0),
      stateRoot: isSet(object.stateRoot) ? Buffer.from(bytesFromBase64(object.stateRoot)) : Buffer.alloc(0),
      txRoot: isSet(object.txRoot) ? Buffer.from(bytesFromBase64(object.txRoot)) : Buffer.alloc(0),
      validator: isSet(object.validator) ? Buffer.from(bytesFromBase64(object.validator)) : Buffer.alloc(0),
    };
  },

  toJSON(message: BlockHeader): unknown {
    const obj: any = {};
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.prevHash.length !== 0) {
      obj.prevHash = base64FromBytes(message.prevHash);
    }
    if (message.stateRoot.length !== 0) {
      obj.stateRoot = base64FromBytes(message.stateRoot);
    }
    if (message.txRoot.length !== 0) {
      obj.txRoot = base64FromBytes(message.txRoot);
    }
    if (message.validator.length !== 0) {
      obj.validator = base64FromBytes(message.validator);
    }
    return obj;
  },

  create(base?: DeepPartial<BlockHeader>): BlockHeader {
    return BlockHeader.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlockHeader>): BlockHeader {
    const message = createBaseBlockHeader();
    message.height = object.height ?? 0;
    message.timestamp = object.timestamp ?? 0;
    message.prevHash = object.prevHash ?? Buffer.alloc(0);
    message.stateRoot = object.stateRoot ?? Buffer.alloc(0);
    message.txRoot = object.txRoot ?? Buffer.alloc(0);
    message.validator = object.validator ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseBlock(): Block {
  return { header: undefined, transactions: [] };
}

export const Block: MessageFns<Block> = {
  encode(message: Block, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      BlockHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    for (const v of message.transactions) {
      Transaction.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Block {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = BlockHeader.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.transactions.push(Transaction.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Block {
    return {
      header: isSet(object.header) ? BlockHeader.fromJSON(object.header) : undefined,
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => Transaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Block): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = BlockHeader.toJSON(message.header);
    }
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => Transaction.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Block>): Block {
    return Block.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Block>): Block {
    const message = createBaseBlock();
    message.header = (object.header !== undefined && object.header !== null)
      ? BlockHeader.fromPartial(object.header)
      : undefined;
    message.transactions = object.transactions?.map((e) => Transaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSubmitTransactionRequest(): SubmitTransactionRequest {
  return { transaction: undefined };
}

export const SubmitTransactionRequest: MessageFns<SubmitTransactionRequest> = {
  encode(message: SubmitTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transaction !== undefined) {
      Transaction.encode(message.transaction, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transaction = Transaction.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitTransactionRequest {
    return { transaction: isSet(object.transaction) ? Transaction.fromJSON(object.transaction) : undefined };
  },

  toJSON(message: SubmitTransactionRequest): unknown {
    const obj: any = {};
    if (message.transaction !== undefined) {
      obj.transaction = Transaction.toJSON(message.transaction);
    }
    return obj;
  },

  create(base?: DeepPartial<SubmitTransactionRequest>): SubmitTransactionRequest {
    return SubmitTransactionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubmitTransactionRequest>): SubmitTransactionRequest {
    const message = createBaseSubmitTransactionRequest();
    message.transaction = (object.transaction !== undefined && object.transaction !== null)
      ? Transaction.fromPartial(object.transaction)
      : undefined;
    return message;
  },
};

function createBaseSubmitTransactionResponse(): SubmitTransactionResponse {
  return {};
}

export const SubmitTransactionResponse: MessageFns<SubmitTransactionResponse> = {
  encode(_: SubmitTransactionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitTransactionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SubmitTransactionResponse {
    return {};
  },

  toJSON(_: SubmitTransactionResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<SubmitTransactionResponse>): SubmitTransactionResponse {
    return SubmitTransactionResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<SubmitTransactionResponse>): SubmitTransactionResponse {
    const message = createBaseSubmitTransactionResponse();
    return message;
  },
};

function createBaseGetValidatorSetRequest(): GetValidatorSetRequest {
  return {};
}

export const GetValidatorSetRequest: MessageFns<GetValidatorSetRequest> = {
  encode(_: GetValidatorSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetValidatorSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetValidatorSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetValidatorSetRequest {
    return {};
  },

  toJSON(_: GetValidatorSetRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<GetValidatorSetRequest>): GetValidatorSetRequest {
    return GetValidatorSetRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetValidatorSetRequest>): GetValidatorSetRequest {
    const message = createBaseGetValidatorSetRequest();
    return message;
  },
};

function createBaseValidator(): Validator {
  return { address: Buffer.alloc(0), power: "" };
}

export const Validator: MessageFns<Validator> = {
  encode(message: Validator, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address.length !== 0) {
      writer.uint32(10).bytes(message.address);
    }
    if (message.power !== "") {
      writer.uint32(18).string(message.power);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Validator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = Buffer.from(reader.bytes());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.power = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Validator {
    return {
      address: isSet(object.address) ? Buffer.from(bytesFromBase64(object.address)) : Buffer.alloc(0),
      power: isSet(object.power) ? globalThis.String(object.power) : "",
    };
  },

  toJSON(message: Validator): unknown {
    const obj: any = {};
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    if (message.power !== "") {
      obj.power = message.power;
    }
    return obj;
  },

  create(base?: DeepPartial<Validator>): Validator {
    return Validator.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Validator>): Validator {
    const message = createBaseValidator();
    message.address = object.address ?? Buffer.alloc(0);
    message.power = object.power ?? "";
    return message;
  },
};

function createBaseGetValidatorSetResponse(): GetValidatorSetResponse {
  return { validators: [] };
}

export const GetValidatorSetResponse: MessageFns<GetValidatorSetResponse> = {
  encode(message: GetValidatorSetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.validators) {
      Validator.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetValidatorSetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetValidatorSetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validators.push(Validator.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetValidatorSetResponse {
    return {
      validators: globalThis.Array.isArray(object?.validators)
        ? object.validators.map((e: any) => Validator.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetValidatorSetResponse): unknown {
    const obj: any = {};
    if (message.validators?.length) {
      obj.validators = message.validators.map((e) => Validator.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetValidatorSetResponse>): GetValidatorSetResponse {
    return GetValidatorSetResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetValidatorSetResponse>): GetValidatorSetResponse {
    const message = createBaseGetValidatorSetResponse();
    message.validators = object.validators?.map((e) => Validator.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetBlockByHeightRequest(): GetBlockByHeightRequest {
  return { height: 0 };
}

export const GetBlockByHeightRequest: MessageFns<GetBlockByHeightRequest> = {
  encode(message: GetBlockByHeightRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.height !== 0) {
      writer.uint32(8).uint64(message.height);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBlockByHeightRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBlockByHeightRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.height = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBlockByHeightRequest {
    return { height: isSet(object.height) ? globalThis.Number(object.height) : 0 };
  },

  toJSON(message: GetBlockByHeightRequest): unknown {
    const obj: any = {};
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    return obj;
  },

  create(base?: DeepPartial<GetBlockByHeightRequest>): GetBlockByHeightRequest {
    return GetBlockByHeightRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBlockByHeightRequest>): GetBlockByHeightRequest {
    const message = createBaseGetBlockByHeightRequest();
    message.height = object.height ?? 0;
    return message;
  },
};

function createBaseGetBlockByHeightResponse(): GetBlockByHeightResponse {
  return { block: undefined };
}

export const GetBlockByHeightResponse: MessageFns<GetBlockByHeightResponse> = {
  encode(message: GetBlockByHeightResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.block !== undefined) {
      Block.encode(message.block, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBlockByHeightResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBlockByHeightResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.block = Block.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBlockByHeightResponse {
    return { block: isSet(object.block) ? Block.fromJSON(object.block) : undefined };
  },

  toJSON(message: GetBlockByHeightResponse): unknown {
    const obj: any = {};
    if (message.block !== undefined) {
      obj.block = Block.toJSON(message.block);
    }
    return obj;
  },

  create(base?: DeepPartial<GetBlockByHeightResponse>): GetBlockByHeightResponse {
    return GetBlockByHeightResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBlockByHeightResponse>): GetBlockByHeightResponse {
    const message = createBaseGetBlockByHeightResponse();
    message.block = (object.block !== undefined && object.block !== null) ? Block.fromPartial(object.block) : undefined;
    return message;
  },
};

function createBaseGetHeightRequest(): GetHeightRequest {
  return {};
}

export const GetHeightRequest: MessageFns<GetHeightRequest> = {
  encode(_: GetHeightRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetHeightRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHeightRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetHeightRequest {
    return {};
  },

  toJSON(_: GetHeightRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<GetHeightRequest>): GetHeightRequest {
    return GetHeightRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetHeightRequest>): GetHeightRequest {
    const message = createBaseGetHeightRequest();
    return message;
  },
};

function createBaseGetHeightResponse(): GetHeightResponse {
  return { height: 0 };
}

export const GetHeightResponse: MessageFns<GetHeightResponse> = {
  encode(message: GetHeightResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.height !== 0) {
      writer.uint32(8).uint64(message.height);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetHeightResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHeightResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.height = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetHeightResponse {
    return { height: isSet(object.height) ? globalThis.Number(object.height) : 0 };
  },

  toJSON(message: GetHeightResponse): unknown {
    const obj: any = {};
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    return obj;
  },

  create(base?: DeepPartial<GetHeightResponse>): GetHeightResponse {
    return GetHeightResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetHeightResponse>): GetHeightResponse {
    const message = createBaseGetHeightResponse();
    message.height = object.height ?? 0;
    return message;
  },
};

function createBaseGetMempoolRequest(): GetMempoolRequest {
  return {};
}

export const GetMempoolRequest: MessageFns<GetMempoolRequest> = {
  encode(_: GetMempoolRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMempoolRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMempoolRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetMempoolRequest {
    return {};
  },

  toJSON(_: GetMempoolRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<GetMempoolRequest>): GetMempoolRequest {
    return GetMempoolRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetMempoolRequest>): GetMempoolRequest {
    const message = createBaseGetMempoolRequest();
    return message;
  },
};

function createBaseGetMempoolResponse(): GetMempoolResponse {
  return { transactions: [] };
}

export const GetMempoolResponse: MessageFns<GetMempoolResponse> = {
  encode(message: GetMempoolResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.transactions) {
      Transaction.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMempoolResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMempoolResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactions.push(Transaction.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMempoolResponse {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => Transaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetMempoolResponse): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => Transaction.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetMempoolResponse>): GetMempoolResponse {
    return GetMempoolResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetMempoolResponse>): GetMempoolResponse {
    const message = createBaseGetMempoolResponse();
    message.transactions = object.transactions?.map((e) => Transaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateBlockRequest(): CreateBlockRequest {
  return { transactions: [] };
}

export const CreateBlockRequest: MessageFns<CreateBlockRequest> = {
  encode(message: CreateBlockRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.transactions) {
      Transaction.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateBlockRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBlockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactions.push(Transaction.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateBlockRequest {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => Transaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreateBlockRequest): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => Transaction.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CreateBlockRequest>): CreateBlockRequest {
    return CreateBlockRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateBlockRequest>): CreateBlockRequest {
    const message = createBaseCreateBlockRequest();
    message.transactions = object.transactions?.map((e) => Transaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateBlockResponse(): CreateBlockResponse {
  return { block: undefined };
}

export const CreateBlockResponse: MessageFns<CreateBlockResponse> = {
  encode(message: CreateBlockResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.block !== undefined) {
      Block.encode(message.block, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateBlockResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBlockResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.block = Block.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateBlockResponse {
    return { block: isSet(object.block) ? Block.fromJSON(object.block) : undefined };
  },

  toJSON(message: CreateBlockResponse): unknown {
    const obj: any = {};
    if (message.block !== undefined) {
      obj.block = Block.toJSON(message.block);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateBlockResponse>): CreateBlockResponse {
    return CreateBlockResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateBlockResponse>): CreateBlockResponse {
    const message = createBaseCreateBlockResponse();
    message.block = (object.block !== undefined && object.block !== null) ? Block.fromPartial(object.block) : undefined;
    return message;
  },
};

function createBaseCommitBlockRequest(): CommitBlockRequest {
  return { block: undefined };
}

export const CommitBlockRequest: MessageFns<CommitBlockRequest> = {
  encode(message: CommitBlockRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.block !== undefined) {
      Block.encode(message.block, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommitBlockRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommitBlockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.block = Block.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommitBlockRequest {
    return { block: isSet(object.block) ? Block.fromJSON(object.block) : undefined };
  },

  toJSON(message: CommitBlockRequest): unknown {
    const obj: any = {};
    if (message.block !== undefined) {
      obj.block = Block.toJSON(message.block);
    }
    return obj;
  },

  create(base?: DeepPartial<CommitBlockRequest>): CommitBlockRequest {
    return CommitBlockRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CommitBlockRequest>): CommitBlockRequest {
    const message = createBaseCommitBlockRequest();
    message.block = (object.block !== undefined && object.block !== null) ? Block.fromPartial(object.block) : undefined;
    return message;
  },
};

function createBaseCommitBlockResponse(): CommitBlockResponse {
  return {};
}

export const CommitBlockResponse: MessageFns<CommitBlockResponse> = {
  encode(_: CommitBlockResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommitBlockResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommitBlockResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CommitBlockResponse {
    return {};
  },

  toJSON(_: CommitBlockResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CommitBlockResponse>): CommitBlockResponse {
    return CommitBlockResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CommitBlockResponse>): CommitBlockResponse {
    const message = createBaseCommitBlockResponse();
    return message;
  },
};

function createBaseGetLastCommitHashRequest(): GetLastCommitHashRequest {
  return {};
}

export const GetLastCommitHashRequest: MessageFns<GetLastCommitHashRequest> = {
  encode(_: GetLastCommitHashRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLastCommitHashRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLastCommitHashRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetLastCommitHashRequest {
    return {};
  },

  toJSON(_: GetLastCommitHashRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<GetLastCommitHashRequest>): GetLastCommitHashRequest {
    return GetLastCommitHashRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetLastCommitHashRequest>): GetLastCommitHashRequest {
    const message = createBaseGetLastCommitHashRequest();
    return message;
  },
};

function createBaseGetLastCommitHashResponse(): GetLastCommitHashResponse {
  return { hash: Buffer.alloc(0) };
}

export const GetLastCommitHashResponse: MessageFns<GetLastCommitHashResponse> = {
  encode(message: GetLastCommitHashResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hash.length !== 0) {
      writer.uint32(10).bytes(message.hash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLastCommitHashResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLastCommitHashResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hash = Buffer.from(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLastCommitHashResponse {
    return { hash: isSet(object.hash) ? Buffer.from(bytesFromBase64(object.hash)) : Buffer.alloc(0) };
  },

  toJSON(message: GetLastCommitHashResponse): unknown {
    const obj: any = {};
    if (message.hash.length !== 0) {
      obj.hash = base64FromBytes(message.hash);
    }
    return obj;
  },

  create(base?: DeepPartial<GetLastCommitHashResponse>): GetLastCommitHashResponse {
    return GetLastCommitHashResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetLastCommitHashResponse>): GetLastCommitHashResponse {
    const message = createBaseGetLastCommitHashResponse();
    message.hash = object.hash ?? Buffer.alloc(0);
    return message;
  },
};

export type ConsensusServiceService = typeof ConsensusServiceService;
export const ConsensusServiceService = {
  submitTxEnvelope: {
    path: "/consensus.v1.ConsensusService/SubmitTxEnvelope",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SubmitTxEnvelopeRequest): Buffer =>
      Buffer.from(SubmitTxEnvelopeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SubmitTxEnvelopeRequest => SubmitTxEnvelopeRequest.decode(value),
    responseSerialize: (value: SubmitTxEnvelopeResponse): Buffer =>
      Buffer.from(SubmitTxEnvelopeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SubmitTxEnvelopeResponse => SubmitTxEnvelopeResponse.decode(value),
  },
  submitTransaction: {
    path: "/consensus.v1.ConsensusService/SubmitTransaction",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SubmitTransactionRequest): Buffer =>
      Buffer.from(SubmitTransactionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SubmitTransactionRequest => SubmitTransactionRequest.decode(value),
    responseSerialize: (value: SubmitTransactionResponse): Buffer =>
      Buffer.from(SubmitTransactionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SubmitTransactionResponse => SubmitTransactionResponse.decode(value),
  },
  getValidatorSet: {
    path: "/consensus.v1.ConsensusService/GetValidatorSet",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetValidatorSetRequest): Buffer =>
      Buffer.from(GetValidatorSetRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetValidatorSetRequest => GetValidatorSetRequest.decode(value),
    responseSerialize: (value: GetValidatorSetResponse): Buffer =>
      Buffer.from(GetValidatorSetResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetValidatorSetResponse => GetValidatorSetResponse.decode(value),
  },
  getBlockByHeight: {
    path: "/consensus.v1.ConsensusService/GetBlockByHeight",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetBlockByHeightRequest): Buffer =>
      Buffer.from(GetBlockByHeightRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetBlockByHeightRequest => GetBlockByHeightRequest.decode(value),
    responseSerialize: (value: GetBlockByHeightResponse): Buffer =>
      Buffer.from(GetBlockByHeightResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetBlockByHeightResponse => GetBlockByHeightResponse.decode(value),
  },
  getHeight: {
    path: "/consensus.v1.ConsensusService/GetHeight",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetHeightRequest): Buffer => Buffer.from(GetHeightRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetHeightRequest => GetHeightRequest.decode(value),
    responseSerialize: (value: GetHeightResponse): Buffer => Buffer.from(GetHeightResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetHeightResponse => GetHeightResponse.decode(value),
  },
  getMempool: {
    path: "/consensus.v1.ConsensusService/GetMempool",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetMempoolRequest): Buffer => Buffer.from(GetMempoolRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetMempoolRequest => GetMempoolRequest.decode(value),
    responseSerialize: (value: GetMempoolResponse): Buffer => Buffer.from(GetMempoolResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetMempoolResponse => GetMempoolResponse.decode(value),
  },
  createBlock: {
    path: "/consensus.v1.ConsensusService/CreateBlock",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateBlockRequest): Buffer => Buffer.from(CreateBlockRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateBlockRequest => CreateBlockRequest.decode(value),
    responseSerialize: (value: CreateBlockResponse): Buffer => Buffer.from(CreateBlockResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CreateBlockResponse => CreateBlockResponse.decode(value),
  },
  commitBlock: {
    path: "/consensus.v1.ConsensusService/CommitBlock",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CommitBlockRequest): Buffer => Buffer.from(CommitBlockRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CommitBlockRequest => CommitBlockRequest.decode(value),
    responseSerialize: (value: CommitBlockResponse): Buffer => Buffer.from(CommitBlockResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CommitBlockResponse => CommitBlockResponse.decode(value),
  },
  getLastCommitHash: {
    path: "/consensus.v1.ConsensusService/GetLastCommitHash",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetLastCommitHashRequest): Buffer =>
      Buffer.from(GetLastCommitHashRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetLastCommitHashRequest => GetLastCommitHashRequest.decode(value),
    responseSerialize: (value: GetLastCommitHashResponse): Buffer =>
      Buffer.from(GetLastCommitHashResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetLastCommitHashResponse => GetLastCommitHashResponse.decode(value),
  },
} as const;

export interface ConsensusServiceServer extends UntypedServiceImplementation {
  submitTxEnvelope: handleUnaryCall<SubmitTxEnvelopeRequest, SubmitTxEnvelopeResponse>;
  submitTransaction: handleUnaryCall<SubmitTransactionRequest, SubmitTransactionResponse>;
  getValidatorSet: handleUnaryCall<GetValidatorSetRequest, GetValidatorSetResponse>;
  getBlockByHeight: handleUnaryCall<GetBlockByHeightRequest, GetBlockByHeightResponse>;
  getHeight: handleUnaryCall<GetHeightRequest, GetHeightResponse>;
  getMempool: handleUnaryCall<GetMempoolRequest, GetMempoolResponse>;
  createBlock: handleUnaryCall<CreateBlockRequest, CreateBlockResponse>;
  commitBlock: handleUnaryCall<CommitBlockRequest, CommitBlockResponse>;
  getLastCommitHash: handleUnaryCall<GetLastCommitHashRequest, GetLastCommitHashResponse>;
}

export interface ConsensusServiceClient extends Client {
  submitTxEnvelope(
    request: SubmitTxEnvelopeRequest,
    callback: (error: ServiceError | null, response: SubmitTxEnvelopeResponse) => void,
  ): ClientUnaryCall;
  submitTxEnvelope(
    request: SubmitTxEnvelopeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SubmitTxEnvelopeResponse) => void,
  ): ClientUnaryCall;
  submitTxEnvelope(
    request: SubmitTxEnvelopeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SubmitTxEnvelopeResponse) => void,
  ): ClientUnaryCall;
  submitTransaction(
    request: SubmitTransactionRequest,
    callback: (error: ServiceError | null, response: SubmitTransactionResponse) => void,
  ): ClientUnaryCall;
  submitTransaction(
    request: SubmitTransactionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SubmitTransactionResponse) => void,
  ): ClientUnaryCall;
  submitTransaction(
    request: SubmitTransactionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SubmitTransactionResponse) => void,
  ): ClientUnaryCall;
  getValidatorSet(
    request: GetValidatorSetRequest,
    callback: (error: ServiceError | null, response: GetValidatorSetResponse) => void,
  ): ClientUnaryCall;
  getValidatorSet(
    request: GetValidatorSetRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetValidatorSetResponse) => void,
  ): ClientUnaryCall;
  getValidatorSet(
    request: GetValidatorSetRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetValidatorSetResponse) => void,
  ): ClientUnaryCall;
  getBlockByHeight(
    request: GetBlockByHeightRequest,
    callback: (error: ServiceError | null, response: GetBlockByHeightResponse) => void,
  ): ClientUnaryCall;
  getBlockByHeight(
    request: GetBlockByHeightRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetBlockByHeightResponse) => void,
  ): ClientUnaryCall;
  getBlockByHeight(
    request: GetBlockByHeightRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetBlockByHeightResponse) => void,
  ): ClientUnaryCall;
  getHeight(
    request: GetHeightRequest,
    callback: (error: ServiceError | null, response: GetHeightResponse) => void,
  ): ClientUnaryCall;
  getHeight(
    request: GetHeightRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetHeightResponse) => void,
  ): ClientUnaryCall;
  getHeight(
    request: GetHeightRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetHeightResponse) => void,
  ): ClientUnaryCall;
  getMempool(
    request: GetMempoolRequest,
    callback: (error: ServiceError | null, response: GetMempoolResponse) => void,
  ): ClientUnaryCall;
  getMempool(
    request: GetMempoolRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetMempoolResponse) => void,
  ): ClientUnaryCall;
  getMempool(
    request: GetMempoolRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetMempoolResponse) => void,
  ): ClientUnaryCall;
  createBlock(
    request: CreateBlockRequest,
    callback: (error: ServiceError | null, response: CreateBlockResponse) => void,
  ): ClientUnaryCall;
  createBlock(
    request: CreateBlockRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateBlockResponse) => void,
  ): ClientUnaryCall;
  createBlock(
    request: CreateBlockRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateBlockResponse) => void,
  ): ClientUnaryCall;
  commitBlock(
    request: CommitBlockRequest,
    callback: (error: ServiceError | null, response: CommitBlockResponse) => void,
  ): ClientUnaryCall;
  commitBlock(
    request: CommitBlockRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CommitBlockResponse) => void,
  ): ClientUnaryCall;
  commitBlock(
    request: CommitBlockRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CommitBlockResponse) => void,
  ): ClientUnaryCall;
  getLastCommitHash(
    request: GetLastCommitHashRequest,
    callback: (error: ServiceError | null, response: GetLastCommitHashResponse) => void,
  ): ClientUnaryCall;
  getLastCommitHash(
    request: GetLastCommitHashRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetLastCommitHashResponse) => void,
  ): ClientUnaryCall;
  getLastCommitHash(
    request: GetLastCommitHashRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetLastCommitHashResponse) => void,
  ): ClientUnaryCall;
}

export const ConsensusServiceClient = makeGenericClientConstructor(
  ConsensusServiceService,
  "consensus.v1.ConsensusService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): ConsensusServiceClient;
  service: typeof ConsensusServiceService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
